-- Lock Database
UPDATE APP_PYME.DATABASECHANGELOGLOCK SET LOCKED = 1, LOCKEDBY = '4777b85455c6 (172.20.0.3)', LOCKGRANTED = SYSTIMESTAMP WHERE ID = 1 AND LOCKED = 0;

-- *********************************************************************
-- Update Database Script
-- *********************************************************************
-- Change Log: changelog-master.xml
-- Ran at: 9/6/25, 2:06 AM
-- Against: APP_PYME@jdbc:oracle:thin:@//oracle-xe:1521/XEPDB1
-- Liquibase version: 4.33.0
-- *********************************************************************

-- Changeset changelog-master.xml::001-tables::sgbd
-- Esquema base Compras/Ventas – Subdistribuidores (PyME)
-- Requiere Oracle 12c+ (IDENTITY)

-- 1) Catálogos y seguridad básica
CREATE TABLE rol (
  id_rol NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nombre VARCHAR2(30) NOT NULL,
  CONSTRAINT pk_rol PRIMARY KEY (id_rol),
  CONSTRAINT uq_rol__nombre UNIQUE (nombre)
);

CREATE TABLE usuario (
  id_usuario NUMBER GENERATED BY DEFAULT AS IDENTITY,
  username VARCHAR2(40) NOT NULL,
  password_hash VARCHAR2(200) NOT NULL,
  nombre VARCHAR2(120) NOT NULL,
  id_rol NUMBER NOT NULL,
  activo CHAR(1) DEFAULT 'S' NOT NULL CHECK (activo IN ('S','N')),
  fecha_creacion TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  creado_por VARCHAR2(60) DEFAULT USER NOT NULL,
  fecha_actualizacion TIMESTAMP(6),
  actualizado_por VARCHAR2(60),
  CONSTRAINT pk_usuario PRIMARY KEY (id_usuario),
  CONSTRAINT uq_usuario__username UNIQUE (username)
);

-- 2) Configuración (IVA u otros parámetros de sistema)
CREATE TABLE parametro_sistema (
  id_parametro NUMBER GENERATED BY DEFAULT AS IDENTITY,
  codigo VARCHAR2(50) NOT NULL,
  valor_num NUMBER(12,4),
  valor_texto VARCHAR2(200),
  descripcion VARCHAR2(200),
  CONSTRAINT pk_parametro_sistema PRIMARY KEY (id_parametro),
  CONSTRAINT uq_parametro__codigo UNIQUE (codigo)
);

-- 3) Maestros de negocio
CREATE TABLE proveedor (
  id_proveedor NUMBER GENERATED BY DEFAULT AS IDENTITY,
  rut VARCHAR2(15) NOT NULL,
  razon_social VARCHAR2(150) NOT NULL,
  giro VARCHAR2(120),
  telefono VARCHAR2(30),
  email VARCHAR2(120),
  direccion VARCHAR2(200),
  activo CHAR(1) DEFAULT 'S' NOT NULL CHECK (activo IN ('S','N')),
  fecha_creacion TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  creado_por VARCHAR2(60) DEFAULT USER NOT NULL,
  fecha_actualizacion TIMESTAMP(6),
  actualizado_por VARCHAR2(60),
  CONSTRAINT pk_proveedor PRIMARY KEY (id_proveedor),
  CONSTRAINT uq_proveedor__rut UNIQUE (rut)
);

CREATE TABLE cliente (
  id_cliente NUMBER GENERATED BY DEFAULT AS IDENTITY,
  rut VARCHAR2(15), -- opcional
  nombre VARCHAR2(150) NOT NULL,
  telefono VARCHAR2(30),
  email VARCHAR2(120),
  direccion VARCHAR2(200),
  activo CHAR(1) DEFAULT 'S' NOT NULL CHECK (activo IN ('S','N')),
  fecha_creacion TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  creado_por VARCHAR2(60) DEFAULT USER NOT NULL,
  fecha_actualizacion TIMESTAMP(6),
  actualizado_por VARCHAR2(60),
  CONSTRAINT pk_cliente PRIMARY KEY (id_cliente),
  CONSTRAINT uq_cliente__rut UNIQUE (rut)
);

CREATE TABLE producto (
  id_producto NUMBER GENERATED BY DEFAULT AS IDENTITY,
  sku VARCHAR2(40) NOT NULL,
  nombre VARCHAR2(150) NOT NULL,
  formato VARCHAR2(10) NOT NULL,
  unidad_medida VARCHAR2(10) DEFAULT 'UN' NOT NULL,
  costo NUMBER(12,2) DEFAULT 0 NOT NULL,
  precio NUMBER(12,2) DEFAULT 0 NOT NULL,
  imagen_url VARCHAR2(300),
  activo CHAR(1) DEFAULT 'S' NOT NULL CHECK (activo IN ('S','N')),
  fecha_creacion TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  creado_por VARCHAR2(60) DEFAULT USER NOT NULL,
  fecha_actualizacion TIMESTAMP(6),
  actualizado_por VARCHAR2(60),
  CONSTRAINT pk_producto PRIMARY KEY (id_producto),
  CONSTRAINT uq_producto__sku UNIQUE (sku),
  CONSTRAINT ck_producto__formato CHECK (formato IN ('5KG','11KG','15KG','45KG','VMF','VMA')),
  CONSTRAINT ck_producto__precios CHECK (costo >= 0 AND precio >= 0)
);

CREATE TABLE inventario (
  id_producto NUMBER NOT NULL,
  stock_actual NUMBER(12,2) DEFAULT 0 NOT NULL,
  stock_minimo NUMBER(12,2) DEFAULT 0 NOT NULL,
  CONSTRAINT pk_inventario PRIMARY KEY (id_producto)
);

-- 4) Compras
CREATE TABLE factura_compra (
  id_factura_compra NUMBER GENERATED BY DEFAULT AS IDENTITY,
  id_proveedor NUMBER NOT NULL,
  numero VARCHAR2(40) NOT NULL,
  fecha DATE NOT NULL,
  direccion_entrega VARCHAR2(200),
  neto NUMBER(14,2) DEFAULT 0 NOT NULL,
  iva NUMBER(14,2) DEFAULT 0 NOT NULL,
  total NUMBER(14,2) DEFAULT 0 NOT NULL,
  id_usuario_registra NUMBER NOT NULL,
  estado VARCHAR2(15) DEFAULT 'BORRADOR' NOT NULL,
  fecha_creacion TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  creado_por VARCHAR2(60) DEFAULT USER NOT NULL,
  fecha_actualizacion TIMESTAMP(6),
  actualizado_por VARCHAR2(60),
  CONSTRAINT pk_factura_compra PRIMARY KEY (id_factura_compra),
  CONSTRAINT ck_fc__estado CHECK (estado IN ('BORRADOR','REGISTRADA','ANULADA'))
);

CREATE TABLE factura_compra_detalle (
  id_detalle NUMBER GENERATED BY DEFAULT AS IDENTITY,
  id_factura_compra NUMBER NOT NULL,
  id_producto NUMBER NOT NULL,
  cantidad NUMBER(12,2) NOT NULL CHECK (cantidad > 0),
  costo_unitario NUMBER(12,2) NOT NULL CHECK (costo_unitario >= 0),
  subtotal NUMBER(14,2) GENERATED ALWAYS AS (ROUND(cantidad * costo_unitario, 2)) VIRTUAL,
  CONSTRAINT pk_fc_detalle PRIMARY KEY (id_detalle),
  CONSTRAINT uq_fc_det__fc_prod UNIQUE (id_factura_compra, id_producto)
);

-- 5) Ventas
CREATE TABLE boleta_venta (
  id_boleta NUMBER GENERATED BY DEFAULT AS IDENTITY,
  numero VARCHAR2(40) NOT NULL, -- serie/nro interno
  fecha DATE DEFAULT TRUNC(SYSDATE) NOT NULL,
  id_usuario_vende NUMBER NOT NULL,
  id_cliente NUMBER, -- opcional
  neto NUMBER(14,2) DEFAULT 0 NOT NULL,
  iva NUMBER(14,2) DEFAULT 0 NOT NULL,
  total NUMBER(14,2) DEFAULT 0 NOT NULL,
  metodo_pago VARCHAR2(30),
  estado VARCHAR2(15) DEFAULT 'CREADA' NOT NULL,
  fecha_creacion TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  creado_por VARCHAR2(60) DEFAULT USER NOT NULL,
  fecha_actualizacion TIMESTAMP(6),
  actualizado_por VARCHAR2(60),
  CONSTRAINT pk_boleta PRIMARY KEY (id_boleta),
  CONSTRAINT ck_boleta__estado CHECK (estado IN ('CREADA','PAGADA','ANULADA'))
);

CREATE TABLE boleta_venta_detalle (
  id_detalle NUMBER GENERATED BY DEFAULT AS IDENTITY,
  id_boleta NUMBER NOT NULL,
  id_producto NUMBER NOT NULL,
  cantidad NUMBER(12,2) NOT NULL CHECK (cantidad > 0),
  precio_unitario NUMBER(12,2) NOT NULL CHECK (precio_unitario >= 0),
  descuento NUMBER(12,2) DEFAULT 0 NOT NULL CHECK (descuento >= 0),
  subtotal NUMBER(14,2) GENERATED ALWAYS AS (ROUND((cantidad * precio_unitario) - descuento, 2)) VIRTUAL,
  CONSTRAINT pk_boleta_detalle PRIMARY KEY (id_detalle),
  CONSTRAINT uq_boleta_det__bol_prod UNIQUE (id_boleta, id_producto)
);

-- 6) Historial de precios (opcional recomendado)
CREATE TABLE producto_precio_hist (
  id_hist NUMBER GENERATED BY DEFAULT AS IDENTITY,
  id_producto NUMBER NOT NULL,
  tipo VARCHAR2(10) NOT NULL CHECK (tipo IN ('COSTO','VENTA')),
  precio NUMBER(12,2) NOT NULL CHECK (precio >= 0),
  vigente_desde DATE DEFAULT TRUNC(SYSDATE) NOT NULL,
  vigente_hasta DATE,
  usuario_registra VARCHAR2(60) DEFAULT USER NOT NULL,
  fecha_creacion TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT pk_producto_precio_hist PRIMARY KEY (id_hist)
);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('001-tables', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 1, '9:9e5bb5fbcf73efe563af12e4edc3d700', 'sqlFile path=../ddl/01_tables.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::002-constraints::sgbd
-- Relaciones usuario/rol
ALTER TABLE usuario
  ADD CONSTRAINT fk_usuario__rol
  FOREIGN KEY (id_rol) REFERENCES rol(id_rol);

-- Inventario 1–1 producto
ALTER TABLE inventario
  ADD CONSTRAINT fk_inventario__producto
  FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

-- Compras
ALTER TABLE factura_compra
  ADD CONSTRAINT fk_fc__proveedor FOREIGN KEY (id_proveedor) REFERENCES proveedor(id_proveedor);

ALTER TABLE factura_compra
  ADD CONSTRAINT fk_fc__usuario FOREIGN KEY (id_usuario_registra) REFERENCES usuario(id_usuario);

ALTER TABLE factura_compra
  ADD CONSTRAINT uq_fc__prov_num UNIQUE (id_proveedor, numero);

ALTER TABLE factura_compra_detalle
  ADD CONSTRAINT fk_fc_det__fc FOREIGN KEY (id_factura_compra) REFERENCES factura_compra(id_factura_compra);

ALTER TABLE factura_compra_detalle
  ADD CONSTRAINT fk_fc_det__producto FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

-- Ventas
ALTER TABLE boleta_venta
  ADD CONSTRAINT fk_bol__usuario FOREIGN KEY (id_usuario_vende) REFERENCES usuario(id_usuario);

ALTER TABLE boleta_venta
  ADD CONSTRAINT fk_bol__cliente FOREIGN KEY (id_cliente) REFERENCES cliente(id_cliente);

ALTER TABLE boleta_venta
  ADD CONSTRAINT uq_boleta__numero UNIQUE (numero);

ALTER TABLE boleta_venta_detalle
  ADD CONSTRAINT fk_bol_det__boleta FOREIGN KEY (id_boleta) REFERENCES boleta_venta(id_boleta);

ALTER TABLE boleta_venta_detalle
  ADD CONSTRAINT fk_bol_det__producto FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

-- Historial de precios
ALTER TABLE producto_precio_hist
  ADD CONSTRAINT fk_pph__producto FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('002-constraints', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 2, '9:100639ce64cd2b92faef98152777812b', 'sqlFile path=../ddl/02_constraints.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::003-idx-producto-nombre::sgbd
CREATE INDEX APP_PYME.IX_PRODUCTO__NOMBRE ON APP_PYME.PRODUCTO(NOMBRE);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('003-idx-producto-nombre', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 3, '9:99d4e1f26ee1c6947be08caab3fdfff5', 'createIndex indexName=IX_PRODUCTO__NOMBRE, tableName=PRODUCTO', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::003-idx-venta-cliente::sgbd
CREATE INDEX APP_PYME.IX_VENTA__CLIENTE_ID ON APP_PYME.VENTA(CLIENTE_ID);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('003-idx-venta-cliente', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 4, '9:ebf986eb3530f7a9f9cfd0ffbf554ad6', 'createIndex indexName=IX_VENTA__CLIENTE_ID, tableName=VENTA', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::003-idx-venta_item-venta::sgbd
CREATE INDEX APP_PYME.IX_VENTA_ITEM__VENTA_ID ON APP_PYME.VENTA_ITEM(VENTA_ID);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('003-idx-venta_item-venta', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 5, '9:ac4387e0e15b595fa094b821ac992959', 'createIndex indexName=IX_VENTA_ITEM__VENTA_ID, tableName=VENTA_ITEM', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::003-idx-venta_item-producto::sgbd
CREATE INDEX APP_PYME.IX_VENTA_ITEM__PRODUCTO_ID ON APP_PYME.VENTA_ITEM(PRODUCTO_ID);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('003-idx-venta_item-producto', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 6, '9:fdc57df5cff94141304f5902dd29ba61', 'createIndex indexName=IX_VENTA_ITEM__PRODUCTO_ID, tableName=VENTA_ITEM', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::004-views::sgbd
-- IVA desde parámetros (si no existe, asume 0.19 en vistas)
-- Ventas por día (solo PAGADA)
CREATE OR REPLACE VIEW v_ventas_diarias AS
SELECT TRUNC(b.fecha) dia,
       SUM(b.total) total_ventas,
       SUM(b.neto)  total_neto,
       SUM(b.iva)   total_iva
FROM boleta_venta b
WHERE b.estado = 'PAGADA'
GROUP BY TRUNC(b.fecha);

-- Compras vs Ventas por día
CREATE OR REPLACE VIEW v_compras_vs_ventas_dia AS
WITH c AS (
  SELECT TRUNC(fecha) dia, SUM(total) compras_total
  FROM factura_compra
  WHERE estado = 'REGISTRADA'
  GROUP BY TRUNC(fecha)
),
v AS (
  SELECT TRUNC(fecha) dia, SUM(total) ventas_total
  FROM boleta_venta
  WHERE estado = 'PAGADA'
  GROUP BY TRUNC(fecha)
)
SELECT COALESCE(c.dia, v.dia) dia,
       NVL(c.compras_total,0) compras_total,
       NVL(v.ventas_total,0) ventas_total
FROM c FULL OUTER JOIN v ON c.dia = v.dia;

-- Stock bajo mínimo
CREATE OR REPLACE VIEW v_stock_bajo_minimo AS
SELECT p.id_producto, p.sku, p.nombre, i.stock_actual, i.stock_minimo
FROM producto p
JOIN inventario i ON i.id_producto = p.id_producto
WHERE i.stock_actual < i.stock_minimo;

-- Ventas por producto (unidades y monto) usando costo actual como aproximación de costo
CREATE OR REPLACE VIEW v_ventas_por_producto AS
SELECT d.id_producto,
       p.sku, p.nombre, p.formato,
       SUM(d.cantidad) unidades_vendidas,
       SUM(d.subtotal) monto_vendido,
       SUM(d.cantidad * p.costo) costo_estimado,
       SUM(d.subtotal) - SUM(d.cantidad * p.costo) utilidad_estimada
FROM boleta_venta_detalle d
JOIN boleta_venta b ON b.id_boleta = d.id_boleta AND b.estado = 'PAGADA'
JOIN producto p ON p.id_producto = d.id_producto
GROUP BY d.id_producto, p.sku, p.nombre, p.formato;

CREATE OR REPLACE VIEW v_boleta_header AS
SELECT b.id_boleta, b.numero, b.fecha, b.neto, b.iva, b.total, b.metodo_pago,
       b.estado, u.nombre AS vendedor, c.nombre AS cliente, c.rut AS rut_cliente
FROM boleta_venta b
JOIN usuario u ON u.id_usuario = b.id_usuario_vende
LEFT JOIN cliente c ON c.id_cliente = b.id_cliente;

CREATE OR REPLACE VIEW v_boleta_detalle AS
SELECT d.id_boleta, p.sku, p.nombre, p.formato,
       d.cantidad, d.precio_unitario, d.descuento, d.subtotal
FROM boleta_venta_detalle d
JOIN producto p ON p.id_producto = d.id_producto;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('004-views', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 7, '9:378a28041927c6a1a0c08890eeeec77b', 'sqlFile path=../ddl/05_views.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::005-seed::sgbd
-- Parámetro IVA (idempotente)
MERGE INTO parametro_sistema t
USING (SELECT 'IVA' codigo, 0.19 valor_num, 'Impuesto IVA Chile' descripcion FROM dual) s
ON (t.codigo = s.codigo)
WHEN MATCHED THEN UPDATE SET t.valor_num = s.valor_num, t.descripcion = s.descripcion
WHEN NOT MATCHED THEN INSERT (codigo, valor_num, descripcion)
VALUES (s.codigo, s.valor_num, s.descripcion);

-- Roles (idempotente por nombre)
MERGE INTO rol t
USING (SELECT 'ADMIN' nombre FROM dual UNION ALL SELECT 'VENTAS' FROM dual) s
ON (t.nombre = s.nombre)
WHEN NOT MATCHED THEN INSERT (nombre) VALUES (s.nombre);

-- Usuarios (idempotente por username; toma id_rol por nombre)
MERGE INTO usuario t
USING (
  SELECT 'AdminPYM' username, 'hash_1234' password_hash, 'Administrador PyME' nombre,
         (SELECT id_rol FROM rol WHERE nombre='ADMIN') id_rol FROM dual
  UNION ALL
  SELECT 'Ventas',   'hash_1234',       'Vendedor',
         (SELECT id_rol FROM rol WHERE nombre='VENTAS') FROM dual
) s
ON (t.username = s.username)
WHEN MATCHED THEN UPDATE SET t.password_hash = s.password_hash, t.nombre = s.nombre, t.id_rol = s.id_rol
WHEN NOT MATCHED THEN INSERT (username, password_hash, nombre, id_rol)
VALUES (s.username, s.password_hash, s.nombre, s.id_rol);

-- Proveedor demo (idempotente por RUT normalizado)
MERGE INTO proveedor t
USING (
  SELECT '76.543.210-9' rut, 'Gas Mayorista Ltda.' razon_social, 'Distribución de gas' giro,
         '+56 2 2345 6789' telefono, 'contacto@gasmayor.cl' email, 'Santiago' direccion, 'S' activo
  FROM dual
) s
ON (t.rut = s.rut)
WHEN MATCHED THEN UPDATE SET
  t.razon_social = s.razon_social, t.giro = s.giro, t.telefono = s.telefono,
  t.email = s.email, t.direccion = s.direccion, t.activo = s.activo,
  t.fecha_actualizacion = SYSTIMESTAMP, t.actualizado_por = USER
WHEN NOT MATCHED THEN INSERT (rut, razon_social, giro, telefono, email, direccion, activo)
VALUES (s.rut, s.razon_social, s.giro, s.telefono, s.email, s.direccion, s.activo);

-- Productos (idempotente por SKU)
MERGE INTO producto t
USING (
  SELECT 'GAS-5'  sku, 'Cilindro Gas 5 Kg'  nombre, '5KG'  formato, 'UN' unidad_medida,  8000 costo, 10500 precio, NULL imagen_url, 'S' activo FROM dual UNION ALL
  SELECT 'GAS-11'     , 'Cilindro Gas 11 Kg', '11KG', 'UN', 14000, 18500, NULL, 'S' FROM dual UNION ALL
  SELECT 'GAS-15'     , 'Cilindro Gas 15 Kg', '15KG', 'UN', 18000, 23500, NULL, 'S' FROM dual UNION ALL
  SELECT 'GAS-45'     , 'Cilindro Gas 45 Kg', '45KG', 'UN', 52000, 68000, NULL, 'S' FROM dual UNION ALL
  SELECT 'GAS-VMF'    , 'Cilindro Gas VMF'  , 'VMF' , 'UN', 20000, 26000, NULL, 'S' FROM dual UNION ALL
  SELECT 'GAS-VMA'    , 'Cilindro Gas VMA'  , 'VMA' , 'UN', 21000, 27000, NULL, 'S' FROM dual
) s
ON (t.sku = s.sku)
WHEN MATCHED THEN UPDATE SET
  t.nombre = s.nombre, t.formato = s.formato, t.unidad_medida = s.unidad_medida,
  t.costo = s.costo, t.precio = s.precio, t.imagen_url = s.imagen_url, t.activo = s.activo,
  t.fecha_actualizacion = SYSTIMESTAMP, t.actualizado_por = USER
WHEN NOT MATCHED THEN INSERT (sku, nombre, formato, unidad_medida, costo, precio, imagen_url, activo)
VALUES (s.sku, s.nombre, s.formato, s.unidad_medida, s.costo, s.precio, s.imagen_url, s.activo);

-- Inventario inicial (1 fila por producto; crea si no existe, y asegura mínimo 5 si es NULL)
MERGE INTO inventario t
USING (SELECT id_producto FROM producto) s
ON (t.id_producto = s.id_producto)
WHEN MATCHED THEN UPDATE SET t.stock_minimo = COALESCE(t.stock_minimo, 5)
WHEN NOT MATCHED THEN INSERT (id_producto, stock_actual, stock_minimo)
VALUES (s.id_producto, 0, 5);

-- Cliente “Consumidor Final” (solo si NO existe ya uno sin RUT con ese nombre)
INSERT INTO cliente (rut, nombre, telefono, email, direccion)
SELECT NULL, 'Consumidor Final', NULL, NULL, NULL
FROM dual
WHERE NOT EXISTS (
  SELECT 1 FROM cliente WHERE rut IS NULL AND nombre = 'Consumidor Final'
);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('005-seed', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 8, '9:710f6222efd548f4bd8820c3c9ea5332', 'sqlFile path=../ddl/06_seed.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::006-triggers::sgbd
-- Helper: obtiene IVA (default 0.19 si no existe)
CREATE OR REPLACE FUNCTION fn_get_iva RETURN NUMBER IS
  v NUMBER := 0.19;
BEGIN
  SELECT NVL(MAX(valor_num),0.19) INTO v
  FROM parametro_sistema WHERE codigo='IVA';
  RETURN v;
EXCEPTION WHEN OTHERS THEN
  RETURN 0.19;
END;
/

-- Recalcular totales de factura_compra
CREATE OR REPLACE PROCEDURE pr_recalc_fc(p_id IN NUMBER) IS
  v_neto NUMBER := 0; v_iva NUMBER := 0; v_total NUMBER := 0;
  v_iva_rate NUMBER := fn_get_iva;
BEGIN
  SELECT NVL(SUM(subtotal),0) INTO v_neto
  FROM factura_compra_detalle WHERE id_factura_compra = p_id;
  v_iva := ROUND(v_neto * v_iva_rate, 2);
  v_total := v_neto + v_iva;

  UPDATE factura_compra
  SET neto = v_neto, iva = v_iva, total = v_total
  WHERE id_factura_compra = p_id;
END;
/

-- Recalcular totales de boleta_venta
CREATE OR REPLACE PROCEDURE pr_recalc_bol(p_id IN NUMBER) IS
  v_neto NUMBER := 0; v_iva NUMBER := 0; v_total NUMBER := 0;
  v_iva_rate NUMBER := fn_get_iva;
BEGIN
  SELECT NVL(SUM(subtotal),0) INTO v_neto
  FROM boleta_venta_detalle WHERE id_boleta = p_id;
  v_iva := ROUND(v_neto * v_iva_rate, 2);
  v_total := v_neto + v_iva;

  UPDATE boleta_venta
  SET neto = v_neto, iva = v_iva, total = v_total
  WHERE id_boleta = p_id;
END;
/

-- Ajusta stock con upsert básico
CREATE OR REPLACE PROCEDURE pr_ajusta_stock(p_id_producto IN NUMBER, p_delta IN NUMBER) IS
BEGIN
  UPDATE inventario
  SET stock_actual = stock_actual + p_delta
  WHERE id_producto = p_id_producto;

  IF SQL%ROWCOUNT = 0 THEN
    INSERT INTO inventario (id_producto, stock_actual, stock_minimo)
    VALUES (p_id_producto, NVL(p_delta,0), 0);
  END IF;
END;
/

-- Recalcular totales al cambiar detalles (compras)
CREATE OR REPLACE TRIGGER trg_fc_det_recalc
FOR INSERT OR UPDATE OR DELETE ON factura_compra_detalle
COMPOUND TRIGGER
  TYPE t_set IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER; -- set de IDs
  g_ids t_set;

  PROCEDURE mark(p NUMBER) IS
  BEGIN
    IF p IS NOT NULL THEN
      g_ids(p) := 1; -- marcar presencia
    END IF;
  END;

  AFTER EACH ROW IS
  BEGIN
    IF INSERTING OR UPDATING THEN
      mark(:NEW.id_factura_compra);
    END IF;
    IF UPDATING OR DELETING THEN
      mark(:OLD.id_factura_compra);
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
    k PLS_INTEGER;
  BEGIN
    k := g_ids.FIRST;
    WHILE k IS NOT NULL LOOP
      pr_recalc_fc(k);
      k := g_ids.NEXT(k);
    END LOOP;
  END AFTER STATEMENT;
END;
/

-- Recalcular totales al cambiar detalles (ventas)
CREATE OR REPLACE TRIGGER trg_bol_det_recalc
FOR INSERT OR UPDATE OR DELETE ON boleta_venta_detalle
COMPOUND TRIGGER
  TYPE t_set IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER; -- set de IDs
  g_ids t_set;

  PROCEDURE mark(p NUMBER) IS
  BEGIN
    IF p IS NOT NULL THEN
      g_ids(p) := 1;
    END IF;
  END;

  AFTER EACH ROW IS
  BEGIN
    IF INSERTING OR UPDATING THEN
      mark(:NEW.id_boleta);
    END IF;
    IF UPDATING OR DELETING THEN
      mark(:OLD.id_boleta);
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
    k PLS_INTEGER;
  BEGIN
    k := g_ids.FIRST;
    WHILE k IS NOT NULL LOOP
      pr_recalc_bol(k);
      k := g_ids.NEXT(k);
    END LOOP;
  END AFTER STATEMENT;
END;
/

-- Movimiento de stock al cambiar estado de FACTURA_COMPRA
CREATE OR REPLACE TRIGGER trg_fc_estado_stock
AFTER UPDATE OF estado ON factura_compra
FOR EACH ROW
BEGIN
  -- BORRADOR -> REGISTRADA : suma stock
  IF :NEW.estado = 'REGISTRADA' AND NVL(:OLD.estado,'BORRADOR') <> 'REGISTRADA' THEN
    FOR r IN (SELECT id_producto, cantidad FROM factura_compra_detalle WHERE id_factura_compra = :NEW.id_factura_compra) LOOP
      pr_ajusta_stock(r.id_producto, r.cantidad);
    END LOOP;
  END IF;

  -- REGISTRADA -> ANULADA : revierte stock
  IF :NEW.estado = 'ANULADA' AND :OLD.estado = 'REGISTRADA' THEN
    FOR r IN (SELECT id_producto, cantidad FROM factura_compra_detalle WHERE id_factura_compra = :NEW.id_factura_compra) LOOP
      pr_ajusta_stock(r.id_producto, -r.cantidad);
    END LOOP;
  END IF;
END;
/

-- Movimiento de stock al cambiar estado de BOLETA_VENTA
CREATE OR REPLACE TRIGGER trg_bol_estado_stock
AFTER UPDATE OF estado ON boleta_venta
FOR EACH ROW
BEGIN
  -- CREADA -> PAGADA : descuenta stock
  IF :NEW.estado = 'PAGADA' AND NVL(:OLD.estado,'CREADA') <> 'PAGADA' THEN
    FOR r IN (SELECT id_producto, cantidad FROM boleta_venta_detalle WHERE id_boleta = :NEW.id_boleta) LOOP
      pr_ajusta_stock(r.id_producto, -r.cantidad);
    END LOOP;
  END IF;

  -- PAGADA -> ANULADA : repone stock
  IF :NEW.estado = 'ANULADA' AND :OLD.estado = 'PAGADA' THEN
    FOR r IN (SELECT id_producto, cantidad FROM boleta_venta_detalle WHERE id_boleta = :NEW.id_boleta) LOOP
      pr_ajusta_stock(r.id_producto, r.cantidad);
    END LOOP;
  END IF;
END;
/

-- Historial de precios: registrar cambios en PRODUCTO (costo/precio)
CREATE OR REPLACE TRIGGER trg_producto_hist_precio
AFTER UPDATE OF costo, precio ON producto
FOR EACH ROW
BEGIN
  IF NVL(:OLD.costo,-1) <> NVL(:NEW.costo,-1) THEN
    INSERT INTO producto_precio_hist (id_producto, tipo, precio, vigente_desde, usuario_registra)
    VALUES (:NEW.id_producto, 'COSTO', :NEW.costo, TRUNC(SYSDATE), USER);
  END IF;
  IF NVL(:OLD.precio,-1) <> NVL(:NEW.precio,-1) THEN
    INSERT INTO producto_precio_hist (id_producto, tipo, precio, vigente_desde, usuario_registra)
    VALUES (:NEW.id_producto, 'VENTA', :NEW.precio, TRUNC(SYSDATE), USER);
  END IF;
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('006-triggers', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 9, '9:539bc4e6845ef4590c4d68203373e79c', 'sqlFile path=../ddl/07_triggers.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::007-ext-tables::sgbd
-- Safe DROP de tablas externas (ignora ORA-00942)
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE ext_proveedores PURGE';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -942 THEN RAISE; END IF;
END;

BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE ext_productos PURGE';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -942 THEN RAISE; END IF;
END;

BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE ext_stock_inicial PURGE';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -942 THEN RAISE; END IF;
END;

BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE ext_clientes PURGE';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -942 THEN RAISE; END IF;
END;

BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE ext_precios PURGE';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -942 THEN RAISE; END IF;
END;

-- External tables SIN SKIP 1; la cabecera se filtra en SELECT del import
CREATE TABLE ext_proveedores (
  rut            VARCHAR2(30),
  razon_social   VARCHAR2(200),
  giro           VARCHAR2(200),
  telefono       VARCHAR2(50),
  email          VARCHAR2(200),
  direccion      VARCHAR2(300),
  activo         VARCHAR2(1)
)
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY IMPORT_DIR
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY NEWLINE
    CHARACTERSET AL32UTF8
    BADFILE 'ext_proveedores.bad'
    LOGFILE 'ext_proveedores.log'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    MISSING FIELD VALUES ARE NULL
  )
  LOCATION ('proveedores.csv')
) REJECT LIMIT UNLIMITED;

CREATE TABLE ext_productos (
  sku           VARCHAR2(40),
  nombre        VARCHAR2(200),
  formato       VARCHAR2(10),
  unidad_medida VARCHAR2(10),
  costo         VARCHAR2(40),
  precio        VARCHAR2(40),
  imagen_url    VARCHAR2(300),
  activo        VARCHAR2(1)
)
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY IMPORT_DIR
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY NEWLINE
    CHARACTERSET AL32UTF8
    BADFILE 'ext_productos.bad'
    LOGFILE 'ext_productos.log'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    MISSING FIELD VALUES ARE NULL
  )
  LOCATION ('productos.csv')
) REJECT LIMIT UNLIMITED;

CREATE TABLE ext_stock_inicial (
  sku            VARCHAR2(40),
  stock_actual   VARCHAR2(40),
  stock_minimo   VARCHAR2(40)
)
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY IMPORT_DIR
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY NEWLINE
    CHARACTERSET AL32UTF8
    BADFILE 'ext_stock_inicial.bad'
    LOGFILE 'ext_stock_inicial.log'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    MISSING FIELD VALUES ARE NULL
  )
  LOCATION ('stock_inicial.csv')
) REJECT LIMIT UNLIMITED;

CREATE TABLE ext_clientes (
  rut         VARCHAR2(30),
  nombre      VARCHAR2(200),
  telefono    VARCHAR2(50),
  email       VARCHAR2(200),
  direccion   VARCHAR2(300),
  activo      VARCHAR2(1)
)
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY IMPORT_DIR
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY NEWLINE
    CHARACTERSET AL32UTF8
    BADFILE 'ext_clientes.bad'
    LOGFILE 'ext_clientes.log'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    MISSING FIELD VALUES ARE NULL
  )
  LOCATION ('clientes.csv')
) REJECT LIMIT UNLIMITED;

CREATE TABLE ext_precios (
  sku    VARCHAR2(40),
  tipo   VARCHAR2(10),
  precio VARCHAR2(40)
)
ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY IMPORT_DIR
  ACCESS PARAMETERS (
    RECORDS DELIMITED BY NEWLINE
    CHARACTERSET AL32UTF8
    BADFILE 'ext_precios.bad'
    LOGFILE 'ext_precios.log'
    FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
    MISSING FIELD VALUES ARE NULL
  )
  LOCATION ('precios.csv')
) REJECT LIMIT UNLIMITED;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('007-ext-tables', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 10, '9:f35a1001d0d3fef73abbfd5fd1dddbb6', 'sqlFile path=../ddl/11_external_tables_drop.sql; sqlFile path=../ddl/11_external_tables_fix.sql', '', 'EXECUTED', 'dev', NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::008a-sucursal-table::sgbd
CREATE TABLE sucursal (
        id_sucursal     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
        nombre          VARCHAR2(100) NOT NULL,
        direccion       VARCHAR2(200),
        comuna          VARCHAR2(100),
        ciudad          VARCHAR2(100),
        activo          CHAR(1) DEFAULT 'S' CHECK (activo IN ('S','N')),
        fecha_creacion  TIMESTAMP DEFAULT SYSTIMESTAMP,
        creado_por      VARCHAR2(50) DEFAULT USER,
        CONSTRAINT pk_sucursal PRIMARY KEY (id_sucursal),
        CONSTRAINT uq_sucursal_nombre UNIQUE (nombre)
      );

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('008a-sucursal-table', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 11, '9:442e860562d0de8e30b228663dc87479', 'sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::008b-inv-add-col-sucursal::sgbd
ALTER TABLE inventario ADD (id_sucursal NUMBER);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('008b-inv-add-col-sucursal', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 12, '9:d2807ad0e37664fb1cead04959e25010', 'sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::008c-inv-fk-sucursal::sgbd
ALTER TABLE inventario
        ADD CONSTRAINT fk_inv_sucursal
        FOREIGN KEY (id_sucursal) REFERENCES sucursal(id_sucursal);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('008c-inv-fk-sucursal', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 13, '9:2962686a4f19af15fd4bae939fd61aec', 'sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::008d-inv-idx-sucursal::sgbd
CREATE INDEX ix_inv__sucursal ON inventario(id_sucursal);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('008d-inv-idx-sucursal', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 14, '9:4d99324777982f8b482910d9c903af2c', 'sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::008e-sucursal-seed::sgbd
DECLARE
        v_id NUMBER;
      BEGIN
        INSERT INTO sucursal(nombre, direccion, ciudad)
        VALUES ('Casa Matriz', NULL, 'Santiago')
        RETURNING id_sucursal INTO v_id;

        UPDATE inventario
           SET id_sucursal = v_id
         WHERE id_sucursal IS NULL;
      END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('008e-sucursal-seed', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 15, '9:119614e856dcd0058f243d8896cf6e0d', 'sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::012-rut-chile::sgbd
-- ===== Funciones utilitarias RUT CL =====
CREATE OR REPLACE FUNCTION fn_rut_only_digits(p_rut VARCHAR2)
RETURN VARCHAR2 DETERMINISTIC IS
  v VARCHAR2(64);
BEGIN
  -- quita puntos, guiones y espacios
  v := UPPER(REGEXP_REPLACE(p_rut, '[\.\- ]', ''));
  RETURN v;
END;
/

CREATE OR REPLACE FUNCTION fn_rut_calc_dv(p_num VARCHAR2)
RETURN VARCHAR2 DETERMINISTIC IS
  -- p_num: solo dígitos (parte izquierda)
  s NUMBER := 0;
  m NUMBER := 2;
  c CHAR(1);
BEGIN
  FOR i IN REVERSE 1..LENGTH(p_num) LOOP
    s := s + TO_NUMBER(SUBSTR(p_num, i, 1)) * m;
    m := CASE WHEN m = 7 THEN 2 ELSE m + 1 END;
  END LOOP;
  s := 11 - MOD(s, 11);
  IF s = 11 THEN c := '0';
  ELSIF s = 10 THEN c := 'K';
  ELSE c := TO_CHAR(s);
  END IF;
  RETURN c;
END;
/

CREATE OR REPLACE FUNCTION fn_rut_valida(p_rut VARCHAR2)
RETURN NUMBER DETERMINISTIC IS
  v VARCHAR2(64) := fn_rut_only_digits(p_rut);
  n VARCHAR2(64);
  dv CHAR(1);
  dv_calc CHAR(1);
BEGIN
  IF p_rut IS NULL THEN RETURN 1; END IF; -- NULL permitido (p.ej. consumidor final)
  IF NOT REGEXP_LIKE(v, '^[0-9]+[0-9K]$') THEN RETURN 0; END IF;
  n := SUBSTR(v, 1, LENGTH(v)-1);
  dv := SUBSTR(v, -1, 1);
  dv_calc := fn_rut_calc_dv(n);
  RETURN CASE WHEN dv_calc = dv THEN 1 ELSE 0 END;
END;
/

CREATE OR REPLACE FUNCTION fn_rut_normaliza(p_rut VARCHAR2)
RETURN VARCHAR2 DETERMINISTIC IS
  v VARCHAR2(64) := fn_rut_only_digits(p_rut);
  n VARCHAR2(64);
  dv CHAR(1);
BEGIN
  IF p_rut IS NULL THEN RETURN NULL; END IF;
  n  := SUBSTR(v, 1, LENGTH(v)-1);
  dv := SUBSTR(v, -1, 1);
  RETURN n || '-' || dv; -- sin puntos, con guión
END;
/

-- ===== Triggers de validación/normalización =====
CREATE OR REPLACE TRIGGER trg_proveedor_rut
BEFORE INSERT OR UPDATE OF rut ON proveedor
FOR EACH ROW
BEGIN
  IF :NEW.rut IS NOT NULL THEN
    IF fn_rut_valida(:NEW.rut) = 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'RUT de proveedor inválido');
    END IF;
    :NEW.rut := fn_rut_normaliza(:NEW.rut);
  END IF;
END;
/
SHOW ERRORS TRIGGER trg_proveedor_rut

CREATE OR REPLACE TRIGGER trg_cliente_rut
BEFORE INSERT OR UPDATE OF rut ON cliente
FOR EACH ROW
BEGIN
  -- RUT es opcional; si viene, debe ser válido
  IF :NEW.rut IS NOT NULL THEN
    IF fn_rut_valida(:NEW.rut) = 0 THEN
      RAISE_APPLICATION_ERROR(-20002, 'RUT de cliente inválido');
    END IF;
    :NEW.rut := fn_rut_normaliza(:NEW.rut);
  END IF;
END;
/
SHOW ERRORS TRIGGER trg_cliente_rut;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('012-rut-chile', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 16, '9:c8644a51567c69434f11217451e85411', 'sqlFile path=../ddl/12_rut_chile.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog-master.xml::013-export-csv::sgbd
-- Helper para comillas y nulls
CREATE OR REPLACE FUNCTION csv_str(p IN VARCHAR2)
RETURN VARCHAR2 DETERMINISTIC IS
BEGIN
  IF p IS NULL THEN RETURN '""'; END IF;
  RETURN '"' || REPLACE(p, '"', '""') || '"';
END;
/

-- Formato numérico con punto decimal
CREATE OR REPLACE FUNCTION csv_num(p IN NUMBER)
RETURN VARCHAR2 DETERMINISTIC IS
BEGIN
  IF p IS NULL THEN RETURN '""'; END IF;
  RETURN '"' || TO_CHAR(p, 'FM9999999990D00', 'NLS_NUMERIC_CHARACTERS=.,') || '"';
END;
/

-- ===== Export: Ventas diarias (por rango) =====
CREATE OR REPLACE PROCEDURE pr_export_ventas_diarias(
  p_desde    IN DATE,
  p_hasta    IN DATE,
  p_filename IN VARCHAR2 DEFAULT 'ventas_diarias.csv'
) IS
  f   UTL_FILE.FILE_TYPE;
BEGIN
  f := UTL_FILE.FOPEN('IMPORT_DIR', p_filename, 'w', 32767);
  UTL_FILE.PUT_LINE(f, 'dia,total_ventas,total_neto,total_iva');

  FOR r IN (
    SELECT TRUNC(b.fecha) dia,
           SUM(b.total) total_ventas,
           SUM(b.neto)  total_neto,
           SUM(b.iva)   total_iva
    FROM boleta_venta b
    WHERE b.estado = 'PAGADA'
      AND b.fecha >= TRUNC(p_desde)
      AND b.fecha <  TRUNC(p_hasta) + 1
    GROUP BY TRUNC(b.fecha)
    ORDER BY 1
  ) LOOP
    UTL_FILE.PUT_LINE(
      f,
      csv_str(TO_CHAR(r.dia, 'YYYY-MM-DD')) || ',' ||
      csv_num(r.total_ventas) || ',' ||
      csv_num(r.total_neto)   || ',' ||
      csv_num(r.total_iva)
    );
  END LOOP;

  UTL_FILE.FCLOSE(f);
END;
/
SHOW ERRORS

-- ===== Export: Ventas por producto (por rango) =====
CREATE OR REPLACE PROCEDURE pr_export_ventas_por_producto(
  p_desde    IN DATE,
  p_hasta    IN DATE,
  p_filename IN VARCHAR2 DEFAULT 'ventas_por_producto.csv'
) IS
  f   UTL_FILE.FILE_TYPE;
BEGIN
  f := UTL_FILE.FOPEN('IMPORT_DIR', p_filename, 'w', 32767);
  UTL_FILE.PUT_LINE(f, 'sku,nombre,unidades_vendidas,monto_vendido,costo_estimado,utilidad_estimada');

  FOR r IN (
    SELECT p.sku,
           p.nombre,
           SUM(d.cantidad)                         unidades_vendidas,
           SUM(d.subtotal)                         monto_vendido,
           SUM(d.cantidad * p.costo)               costo_estimado,
           SUM(d.subtotal) - SUM(d.cantidad*p.costo) utilidad_estimada
    FROM boleta_venta_detalle d
    JOIN boleta_venta b ON b.id_boleta = d.id_boleta AND b.estado = 'PAGADA'
    JOIN producto p     ON p.id_producto = d.id_producto
    WHERE b.fecha >= TRUNC(p_desde)
      AND b.fecha <  TRUNC(p_hasta) + 1
    GROUP BY p.sku, p.nombre
    ORDER BY p.sku
  ) LOOP
    UTL_FILE.PUT_LINE(
      f,
      csv_str(r.sku) || ',' ||
      csv_str(r.nombre) || ',' ||
      csv_num(r.unidades_vendidas) || ',' ||
      csv_num(r.monto_vendido) || ',' ||
      csv_num(r.costo_estimado) || ',' ||
      csv_num(r.utilidad_estimada)
    );
  END LOOP;

  UTL_FILE.FCLOSE(f);
END;
/
SHOW ERRORS;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('013-export-csv', 'sgbd', 'changelog-master.xml', SYSTIMESTAMP, 17, '9:03ba540babd0276058667a32e0d26fcd', 'sqlFile path=../ddl/13_export_csv.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/013-export-dir.xml::013c-export-dir-nonadmin-assert::sgbd
BEGIN NULL; END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('013c-export-dir-nonadmin-assert', 'sgbd', 'changelog/013-export-dir.xml', SYSTIMESTAMP, 18, '9:5be7077dd3429beba12fcde1a979d5bb', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/014-mv-kpis.xml::014b1-mv-vpp-desde-boleta::sgbd
CREATE MATERIALIZED VIEW mv_ventas_por_producto
      BUILD IMMEDIATE
      REFRESH COMPLETE ON DEMAND
      AS
      SELECT
        vi.sku,
        p.nombre,
        SUM(vi.cantidad)                   AS unidades_vendidas,
        SUM(vi.total)                      AS monto_vendido,
        SUM(vi.cantidad * NVL(p.costo,0))  AS costo_estimado,
        SUM(vi.total) - SUM(vi.cantidad * NVL(p.costo,0)) AS utilidad_estimada
      FROM boleta_item vi
      JOIN producto p     ON p.sku = vi.sku
      JOIN boleta_venta b ON b.id_boleta = vi.id_boleta
      WHERE b.estado = 'PAGADA'
      GROUP BY vi.sku, p.nombre;

CREATE INDEX ix_mv_vpp__sku ON mv_ventas_por_producto(sku);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('014b1-mv-vpp-desde-boleta', 'sgbd', 'changelog/014-mv-kpis.xml', SYSTIMESTAMP, 19, '9:9f87e476cc007b5ebc0615b8bbb04a55', 'sql; sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/014-mv-kpis.xml::014b2-mv-vpp-desde-venta::sgbd
CREATE MATERIALIZED VIEW mv_ventas_por_producto
      BUILD IMMEDIATE
      REFRESH COMPLETE ON DEMAND
      AS
      SELECT
        vi.sku,
        p.nombre,
        SUM(vi.cantidad)                   AS unidades_vendidas,
        SUM(vi.total)                      AS monto_vendido,
        SUM(vi.cantidad * NVL(p.costo,0))  AS costo_estimado,
        SUM(vi.total) - SUM(vi.cantidad * NVL(p.costo,0)) AS utilidad_estimada
      FROM venta_item vi
      JOIN producto p ON p.sku = vi.sku
      JOIN venta v    ON v.id_venta = vi.id_venta
      WHERE v.estado = 'PAGADA'
      GROUP BY vi.sku, p.nombre;

CREATE INDEX ix_mv_vpp__sku ON mv_ventas_por_producto(sku);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('014b2-mv-vpp-desde-venta', 'sgbd', 'changelog/014-mv-kpis.xml', SYSTIMESTAMP, 20, '9:afd115b66b4cdbc6ef7938f54bdf1015', 'sql; sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/014b-mv-vpp.xml::014b1-mv-vpp-desde-boleta::sgbd
CREATE MATERIALIZED VIEW mv_ventas_por_producto
      BUILD IMMEDIATE
      REFRESH COMPLETE ON DEMAND
      AS
      SELECT
        vi.sku,
        p.nombre,
        SUM(vi.cantidad)                   AS unidades_vendidas,
        SUM(vi.total)                      AS monto_vendido,
        SUM(vi.cantidad * NVL(p.costo,0))  AS costo_estimado,
        SUM(vi.total) - SUM(vi.cantidad * NVL(p.costo,0)) AS utilidad_estimada
      FROM boleta_item vi
      JOIN producto p     ON p.sku = vi.sku
      JOIN boleta_venta b ON b.id_boleta = vi.id_boleta
      WHERE b.estado = 'PAGADA'
      GROUP BY vi.sku, p.nombre;

CREATE INDEX ix_mv_vpp__sku ON mv_ventas_por_producto(sku);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('014b1-mv-vpp-desde-boleta', 'sgbd', 'changelog/014b-mv-vpp.xml', SYSTIMESTAMP, 21, '9:9f87e476cc007b5ebc0615b8bbb04a55', 'sql; sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/014b-mv-vpp.xml::014b2-mv-vpp-desde-venta::sgbd
CREATE MATERIALIZED VIEW mv_ventas_por_producto
      BUILD IMMEDIATE
      REFRESH COMPLETE ON DEMAND
      AS
      SELECT
        vi.sku,
        p.nombre,
        SUM(vi.cantidad)                   AS unidades_vendidas,
        SUM(vi.total)                      AS monto_vendido,
        SUM(vi.cantidad * NVL(p.costo,0))  AS costo_estimado,
        SUM(vi.total) - SUM(vi.cantidad * NVL(p.costo,0)) AS utilidad_estimada
      FROM venta_item vi
      JOIN producto p ON p.sku = vi.sku
      JOIN venta v    ON v.id_venta = vi.id_venta
      WHERE v.estado = 'PAGADA'
      GROUP BY vi.sku, p.nombre;

CREATE INDEX ix_mv_vpp__sku ON mv_ventas_por_producto(sku);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('014b2-mv-vpp-desde-venta', 'sgbd', 'changelog/014b-mv-vpp.xml', SYSTIMESTAMP, 22, '9:afd115b66b4cdbc6ef7938f54bdf1015', 'sql; sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/014b-mv-vpp.xml::014b3-mv-vpp-desde-boleta-retry::sgbd
CREATE MATERIALIZED VIEW mv_ventas_por_producto
    BUILD IMMEDIATE
    REFRESH COMPLETE ON DEMAND
    AS
    SELECT
      vi.sku,
      p.nombre,
      SUM(vi.cantidad)                   AS unidades_vendidas,
      SUM(vi.total)                      AS monto_vendido,
      SUM(vi.cantidad * NVL(p.costo,0))  AS costo_estimado,
      SUM(vi.total) - SUM(vi.cantidad * NVL(p.costo,0)) AS utilidad_estimada
    FROM boleta_item vi
    JOIN producto p     ON p.sku = vi.sku
    JOIN boleta_venta b ON b.id_boleta = vi.id_boleta
    WHERE b.estado = 'PAGADA'
    GROUP BY vi.sku, p.nombre;

CREATE INDEX ix_mv_vpp__sku ON mv_ventas_por_producto(sku);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('014b3-mv-vpp-desde-boleta-retry', 'sgbd', 'changelog/014b-mv-vpp.xml', SYSTIMESTAMP, 23, '9:9f87e476cc007b5ebc0615b8bbb04a55', 'sql; sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/014b-mv-vpp.xml::014b4-mv-vpp-boleta-detalle::sgbd
CREATE MATERIALIZED VIEW mv_ventas_por_producto
      BUILD IMMEDIATE
      REFRESH COMPLETE ON DEMAND
      AS
      SELECT
        p.sku,
        p.nombre,
        SUM(d.cantidad)                               AS unidades_vendidas,
        SUM(d.subtotal)                               AS monto_vendido,
        SUM(d.cantidad * NVL(p.costo,0))              AS costo_estimado,
        SUM(d.subtotal) - SUM(d.cantidad * NVL(p.costo,0)) AS utilidad_estimada
      FROM boleta_venta_detalle d
      JOIN producto p     ON p.id_producto = d.id_producto
      JOIN boleta_venta b ON b.id_boleta   = d.id_boleta
      WHERE b.estado = 'PAGADA'
      GROUP BY p.sku, p.nombre;

CREATE INDEX ix_mv_vpp__sku ON mv_ventas_por_producto(sku);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('014b4-mv-vpp-boleta-detalle', 'sgbd', 'changelog/014b-mv-vpp.xml', SYSTIMESTAMP, 24, '9:b23349c20e28c711bf75b772526bdf1b', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/014b-mv-vpp.xml::017d-view-kpi-vpp-if-mv::sgbd
CREATE OR REPLACE VIEW v_kpi_ventas_por_producto AS
      SELECT
        sku,
        nombre,
        unidades_vendidas,
        monto_vendido,
        costo_estimado,
        utilidad_estimada
      FROM mv_ventas_por_producto;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('017d-view-kpi-vpp-if-mv', 'sgbd', 'changelog/014b-mv-vpp.xml', SYSTIMESTAMP, 25, '9:3e6b2f5b00be4b390d7955ee31ca17d0', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/015-scheduler-kpis.xml::015-scheduler-kpis::sgbd
CREATE OR REPLACE PROCEDURE pr_refresh_kpi_mv AS
BEGIN
  DBMS_MVIEW.REFRESH('MV_VENTAS_DIARIAS', 'C');
  DBMS_MVIEW.REFRESH('MV_VENTAS_POR_PRODUCTO', 'C');
END;

BEGIN
  DBMS_SCHEDULER.DROP_JOB('JOB_REFRESH_KPI_MV', TRUE);
EXCEPTION WHEN OTHERS THEN NULL;
END;

BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name        => 'JOB_REFRESH_KPI_MV',
    job_type        => 'STORED_PROCEDURE',
    job_action      => 'PR_REFRESH_KPI_MV',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=2;BYMINUTE=30;BYSECOND=0',
    enabled         => TRUE,
    comments        => 'Refresco nocturno de MVs KPI'
  );
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('015-scheduler-kpis', 'sgbd', 'changelog/015-scheduler-kpis.xml', SYSTIMESTAMP, 26, '9:e370a3439cb99863064f074eec7fbd30', 'sqlFile path=../../ddl/15_scheduler_kpis.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/016-export-procs.xml::016-export-procs::sgbd
-- ddl/13b_export_procs.sql
CREATE OR REPLACE PROCEDURE pr_export_ventas_diarias(
  p_desde    DATE,
  p_hasta    DATE,
  p_filename VARCHAR2
) AS
  f UTL_FILE.FILE_TYPE;
BEGIN
  f := UTL_FILE.FOPEN('EXPORT_DIR', p_filename, 'w', 32767);
  UTL_FILE.PUT_LINE(f, 'dia,total_ventas,total_neto,total_iva');
  FOR r IN (
    SELECT TO_CHAR(dia,'YYYY-MM-DD') AS d,
           total_ventas, total_neto, total_iva
    FROM mv_ventas_diarias
    WHERE dia BETWEEN TRUNC(p_desde) AND TRUNC(p_hasta)
    ORDER BY dia
  ) LOOP
    UTL_FILE.PUT_LINE(f, r.d||','||r.total_ventas||','||r.total_neto||','||r.total_iva);
  END LOOP;
  UTL_FILE.FCLOSE(f);
END;

CREATE OR REPLACE PROCEDURE pr_export_ventas_por_producto(
  p_desde    DATE,
  p_hasta    DATE,
  p_filename VARCHAR2
) AS
  f UTL_FILE.FILE_TYPE;
BEGIN
  f := UTL_FILE.FOPEN('EXPORT_DIR', p_filename, 'w', 32767);
  UTL_FILE.PUT_LINE(f, 'sku,nombre,unidades_vendidas,monto_vendido,costo_estimado,utilidad_estimada');

  FOR r IN (
    SELECT p.sku, p.nombre,
           SUM(d.cantidad)                       AS unidades_vendidas,
           SUM(d.subtotal)                       AS monto_vendido,
           SUM(d.cantidad * p.costo)             AS costo_estimado,
           SUM(d.subtotal) - SUM(d.cantidad*p.costo) AS utilidad_estimada
    FROM boleta_venta_detalle d
    JOIN boleta_venta b ON b.id_boleta = d.id_boleta AND b.estado='PAGADA'
    JOIN producto p     ON p.id_producto = d.id_producto
    WHERE TRUNC(b.fecha) BETWEEN TRUNC(p_desde) AND TRUNC(p_hasta)
    GROUP BY p.sku, p.nombre
    ORDER BY p.sku
  ) LOOP
    UTL_FILE.PUT_LINE(f,
      r.sku||','||
      REPLACE(r.nombre,',',' ')||','||
      r.unidades_vendidas||','||
      r.monto_vendido||','||
      r.costo_estimado||','||
      r.utilidad_estimada
    );
  END LOOP;

  UTL_FILE.FCLOSE(f);
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('016-export-procs', 'sgbd', 'changelog/016-export-procs.xml', SYSTIMESTAMP, 27, '9:f72df29a67515064b5b976937c0c2fee', 'sqlFile path=../../ddl/13b_export_procs.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/017-views-kpi.xml::017a-view-kpi-ventas-diarias::sgbd
CREATE OR REPLACE VIEW v_kpi_ventas_diarias AS
SELECT
  dia,
  total_ventas,
  total_neto,
  total_iva
FROM mv_ventas_diarias;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('017a-view-kpi-ventas-diarias', 'sgbd', 'changelog/017-views-kpi.xml', SYSTIMESTAMP, 28, '9:daa45a59521d12ee3eb1476b31eae924', 'sqlFile path=../../ddl/17a_view_kpi_ventas_diarias.sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/017-views-kpi.xml::017b-view-kpi-ventas-por-producto::sgbd
CREATE OR REPLACE VIEW v_kpi_ventas_por_producto AS
SELECT
  sku,
  nombre,
  unidades_vendidas,
  monto_vendido,
  costo_estimado,
  utilidad_estimada
FROM mv_ventas_por_producto;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('017b-view-kpi-ventas-por-producto', 'sgbd', 'changelog/017-views-kpi.xml', SYSTIMESTAMP, 29, '9:3e6b2f5b00be4b390d7955ee31ca17d0', 'sqlFile path=../../ddl/17b_view_kpi_ventas_por_producto.sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/017-views-kpi.xml::017c-view-kpi-vpp-create-if-mv::sgbd
CREATE OR REPLACE VIEW v_kpi_ventas_por_producto AS
    SELECT
      sku,
      nombre,
      unidades_vendidas,
      monto_vendido,
      costo_estimado,
      utilidad_estimada
    FROM mv_ventas_por_producto;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('017c-view-kpi-vpp-create-if-mv', 'sgbd', 'changelog/017-views-kpi.xml', SYSTIMESTAMP, 30, '9:ee70f7464ccdbf0eb8498168bdcce0f1', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/018-scheduler-export.xml::018-scheduler-export::sgbd
-- Procedure que refresca MVs y exporta CSVs con fecha
CREATE OR REPLACE PROCEDURE pr_export_kpis_daily AS
  v_stamp VARCHAR2(8) := TO_CHAR(SYSDATE,'YYYYMMDD');
BEGIN
  -- refresco
  pr_refresh_kpi_mv;

  -- export del día
  pr_export_ventas_diarias(
    TRUNC(SYSDATE), TRUNC(SYSDATE),
    'ventas_hoy_'||v_stamp||'.csv'
  );

  -- export últimos 7 días por producto
  pr_export_ventas_por_producto(
    TRUNC(SYSDATE)-6, TRUNC(SYSDATE),
    'ventas_prod_ult7d_'||v_stamp||'.csv'
  );
END;

-- (re)crear job diario
BEGIN
  DBMS_SCHEDULER.DROP_JOB('JOB_EXPORT_KPI_DAILY', TRUE);
EXCEPTION WHEN OTHERS THEN NULL;
END;

BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name        => 'JOB_EXPORT_KPI_DAILY',
    job_type        => 'STORED_PROCEDURE',
    job_action      => 'PR_EXPORT_KPIS_DAILY',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=2;BYMINUTE=35;BYSECOND=0',
    enabled         => TRUE,
    comments        => 'Exporta KPI CSV diariamente tras el refresh de MVs'
  );
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('018-scheduler-export', 'sgbd', 'changelog/018-scheduler-export.xml', SYSTIMESTAMP, 31, '9:b6588fcd5a516aa294a55b1e1947bfab', 'sqlFile path=../../ddl/18_scheduler_export.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/019-indexes-perf.xml::019-indexes-perf::sgbd
-- 19_indexes_perf.sql (idempotente, bloque único para Liquibase/JDBC)
DECLARE
  PROCEDURE try_create(p_sql IN VARCHAR2) IS
  BEGIN
    EXECUTE IMMEDIATE p_sql;
  EXCEPTION
    WHEN OTHERS THEN
      -- -955: nombre ya usado por un objeto existente
      -- -1408: ya existe un índice con esa lista de columnas
      IF SQLCODE NOT IN (-955, -1408) THEN
        RAISE;
      END IF;
  END;
BEGIN
  try_create('CREATE INDEX ix_boleta_venta__estado_fecha ON boleta_venta(estado, fecha)');
  try_create('CREATE INDEX ix_bv_detalle__id_producto ON boleta_venta_detalle(id_producto)');
  try_create('CREATE INDEX ix_producto__sku ON producto(sku)');
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('019-indexes-perf', 'sgbd', 'changelog/019-indexes-perf.xml', SYSTIMESTAMP, 32, '9:1bcc51fbef7064eb5fa967fd43fd181a', 'sqlFile path=../../ddl/19_indexes_perf.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/020-monitoring.xml::020-monitoring::sgbd
SELECT job_name,
       state,
       TO_CHAR(last_start_date,'YYYY-MM-DD HH24:MI') last_start_date,
       TO_CHAR(next_run_date,'YYYY-MM-DD HH24:MI') next_run_date
FROM user_scheduler_jobs
ORDER BY job_name;

SELECT * FROM (
  SELECT job_name,
         status,
         TO_CHAR(log_date,'YYYY-MM-DD HH24:MI') log_date,
         error#,
         additional_info
  FROM user_scheduler_job_run_details
  ORDER BY log_date DESC
) WHERE ROWNUM <= 20;

SELECT mview_name,
       staleness,
       TO_CHAR(last_refresh_date,'YYYY-MM-DD HH24:MI') last_refresh_date
FROM user_mviews
ORDER BY mview_name;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('020-monitoring', 'sgbd', 'changelog/020-monitoring.xml', SYSTIMESTAMP, 33, '9:f8c1388d3ed856e0fefbebc294bc2a43', 'sqlFile path=../../scripts/check_jobs.sql', '', 'EXECUTED', 'dev', NULL, '4.33.0', '7124371332');

-- Changeset changelog/021-core-ubicaciones-inventario.xml::021-core-ubicaciones-inventario::sgbd
CREATE TABLE ubicacion (
  id_ubicacion NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nombre       VARCHAR2(100) NOT NULL,
  tipo         VARCHAR2(20)  NOT NULL CHECK (tipo IN ('BODEGA','LOCAL','CAMIONETA','FAMILIAR')),
  activo       CHAR(1) DEFAULT 'S' NOT NULL CHECK (activo IN ('S','N')),
  CONSTRAINT pk_ubicacion PRIMARY KEY (id_ubicacion),
  CONSTRAINT uq_ubicacion__nombre UNIQUE (nombre)
);

CREATE TABLE stock_ubicacion (
  id_ubicacion NUMBER NOT NULL,
  id_producto  NUMBER NOT NULL,
  llenos       NUMBER DEFAULT 0 NOT NULL,
  vacios       NUMBER DEFAULT 0 NOT NULL,
  fecha_actualizacion TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT pk_stock_ubicacion PRIMARY KEY (id_ubicacion, id_producto)
);

CREATE TABLE movimiento_stock (
  id_mov             NUMBER GENERATED BY DEFAULT AS IDENTITY,
  fecha              TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  tipo               VARCHAR2(20) NOT NULL CHECK (tipo IN ('COMPRA','VENTA','TRASLADO','AJUSTE','CONTEO')),
  id_ubicacion_desde NUMBER,
  id_ubicacion_hasta NUMBER,
  id_producto        NUMBER NOT NULL,
  cantidad           NUMBER NOT NULL,
  es_lleno           CHAR(1) DEFAULT 'S' NOT NULL CHECK (es_lleno IN ('S','N')),
  ref_tipo           VARCHAR2(30),
  ref_id             NUMBER,
  observacion        VARCHAR2(200),
  CONSTRAINT pk_movimiento_stock PRIMARY KEY (id_mov)
);

ALTER TABLE stock_ubicacion ADD CONSTRAINT fk_stock_ubi__ubicacion FOREIGN KEY (id_ubicacion) REFERENCES ubicacion(id_ubicacion);

ALTER TABLE stock_ubicacion ADD CONSTRAINT fk_stock_ubi__producto FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

ALTER TABLE movimiento_stock ADD CONSTRAINT fk_mov_stock__ubi_desde FOREIGN KEY (id_ubicacion_desde) REFERENCES ubicacion(id_ubicacion);

ALTER TABLE movimiento_stock ADD CONSTRAINT fk_mov_stock__ubi_hasta FOREIGN KEY (id_ubicacion_hasta) REFERENCES ubicacion(id_ubicacion);

ALTER TABLE movimiento_stock ADD CONSTRAINT fk_mov_stock__producto FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

CREATE INDEX ix_mov_stock__tipo_fecha ON movimiento_stock (tipo, fecha);

CREATE INDEX ix_mov_stock__id_producto ON movimiento_stock (id_producto);

CREATE INDEX ix_mov_stock__id_ubi_desde ON movimiento_stock (id_ubicacion_desde);

CREATE INDEX ix_mov_stock__id_ubi_hasta ON movimiento_stock (id_ubicacion_hasta);

MERGE INTO ubicacion u
USING (
  SELECT 'BODEGA 1' AS nombre, 'BODEGA' AS tipo FROM dual UNION ALL
  SELECT 'LOCAL'    AS nombre, 'LOCAL'  AS tipo FROM dual UNION ALL
  SELECT 'CAMIONETA' AS nombre, 'CAMIONETA' AS tipo FROM dual UNION ALL
  SELECT 'FAMILIAR' AS nombre, 'FAMILIAR' AS tipo FROM dual
) s
ON (u.nombre = s.nombre)
WHEN NOT MATCHED THEN
  INSERT (nombre, tipo, activo) VALUES (s.nombre, s.tipo, 'S');

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('021-core-ubicaciones-inventario', 'sgbd', 'changelog/021-core-ubicaciones-inventario.xml', SYSTIMESTAMP, 34, '9:d1c41aee4ffb7e549986062f046583c5', 'sqlFile path=../../ddl/021_core_ubicaciones_inventario.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/022-conteos-diarios.xml::022-conteos-diarios::sgbd
CREATE TABLE conteo_inv_cab (
  id_conteo    NUMBER GENERATED BY DEFAULT AS IDENTITY,
  fecha        DATE NOT NULL,
  hora         VARCHAR2(8) NOT NULL,
  id_ubicacion NUMBER NOT NULL,
  responsable  VARCHAR2(100),
  confirmado   CHAR(1) DEFAULT 'N' NOT NULL CHECK (confirmado IN ('S','N')),
  creado_por   VARCHAR2(30),
  creado_en    TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT pk_conteo_inv_cab PRIMARY KEY (id_conteo)
);

ALTER TABLE conteo_inv_cab
  ADD CONSTRAINT fk_conteo_cab__ubicacion
  FOREIGN KEY (id_ubicacion) REFERENCES ubicacion(id_ubicacion);

CREATE TABLE conteo_inv_det (
  id_conteo   NUMBER NOT NULL,
  id_producto NUMBER NOT NULL,
  llenos      NUMBER DEFAULT 0 NOT NULL,
  vacios      NUMBER DEFAULT 0 NOT NULL,
  CONSTRAINT pk_conteo_inv_det PRIMARY KEY (id_conteo, id_producto)
);

ALTER TABLE conteo_inv_det
  ADD CONSTRAINT fk_conteo_det__cab
  FOREIGN KEY (id_conteo) REFERENCES conteo_inv_cab(id_conteo) ON DELETE CASCADE;

ALTER TABLE conteo_inv_det
  ADD CONSTRAINT fk_conteo_det__producto
  FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('022-conteos-diarios', 'sgbd', 'changelog/022-conteos-diarios.xml', SYSTIMESTAMP, 35, '9:51aa2d07987af2fcffb0ca90af810aa1', 'sqlFile path=../../ddl/022_conteos_diarios.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/022-conteos-diarios.xml::022-conteos-diarios-proc::sgbd
CREATE OR REPLACE PROCEDURE pr_conteo_confirmar(p_id_conteo IN NUMBER) IS
  v_id_ubicacion ubicacion.id_ubicacion%TYPE;
  v_confirmado  conteo_inv_cab.confirmado%TYPE;
BEGIN
  SELECT id_ubicacion, confirmado
    INTO v_id_ubicacion, v_confirmado
    FROM conteo_inv_cab
   WHERE id_conteo = p_id_conteo
   FOR UPDATE;

  IF v_confirmado = 'S' THEN
    RETURN;
  END IF;

  FOR r IN (
    SELECT d.id_producto,
           d.llenos,
           d.vacios,
           NVL(s.llenos,0) AS llenos_actual,
           NVL(s.vacios,0) AS vacios_actual
      FROM conteo_inv_det d
      LEFT JOIN stock_ubicacion s
        ON s.id_ubicacion = v_id_ubicacion
       AND s.id_producto  = d.id_producto
     WHERE d.id_conteo = p_id_conteo
  ) LOOP
    DECLARE
      v_diff_llenos NUMBER := r.llenos - r.llenos_actual;
      v_diff_vacios NUMBER := r.vacios - r.vacios_actual;
    BEGIN
      MERGE INTO stock_ubicacion su
      USING dual
         ON (su.id_ubicacion = v_id_ubicacion AND su.id_producto = r.id_producto)
      WHEN MATCHED THEN
        UPDATE SET su.llenos = r.llenos,
                   su.vacios = r.vacios,
                   su.fecha_actualizacion = SYSTIMESTAMP
      WHEN NOT MATCHED THEN
        INSERT (id_ubicacion, id_producto, llenos, vacios, fecha_actualizacion)
        VALUES (v_id_ubicacion, r.id_producto, r.llenos, r.vacios, SYSTIMESTAMP);

      IF v_diff_llenos <> 0 THEN
        INSERT INTO movimiento_stock (fecha, tipo, id_ubicacion_desde, id_ubicacion_hasta,
                                      id_producto, cantidad, es_lleno, ref_tipo, ref_id)
        VALUES (SYSTIMESTAMP, 'CONTEO', v_id_ubicacion, v_id_ubicacion,
                r.id_producto, v_diff_llenos, 'S', 'CONTEO_INV', p_id_conteo);
      END IF;

      IF v_diff_vacios <> 0 THEN
        INSERT INTO movimiento_stock (fecha, tipo, id_ubicacion_desde, id_ubicacion_hasta,
                                      id_producto, cantidad, es_lleno, ref_tipo, ref_id)
        VALUES (SYSTIMESTAMP, 'CONTEO', v_id_ubicacion, v_id_ubicacion,
                r.id_producto, v_diff_vacios, 'N', 'CONTEO_INV', p_id_conteo);
      END IF;
    END;
  END LOOP;

  UPDATE conteo_inv_cab
     SET confirmado = 'S'
   WHERE id_conteo = p_id_conteo;
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('022-conteos-diarios-proc', 'sgbd', 'changelog/022-conteos-diarios.xml', SYSTIMESTAMP, 36, '9:832942cd54bb5452f4ddfd661916cec3', 'sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/023-pendientes-vacio.xml::023-pendientes-vacio::sgbd
-- 023 - Pendientes de devolución de vacío (secuencia + trigger, en un bloque)

DECLARE
  c_e_obj_exists CONSTANT PLS_INTEGER := -955;   -- nombre ya existe
  c_e_fk_exists  CONSTANT PLS_INTEGER := -2261;  -- FK ya existe
  c_e_fk_dup     CONSTANT PLS_INTEGER := -2275;  -- FK duplicada / ya creada
BEGIN
  -- Tabla
  BEGIN
    EXECUTE IMMEDIATE q'[
      CREATE TABLE pendiente_vacio (
        id_pend       NUMBER PRIMARY KEY,
        id_cliente    NUMBER NOT NULL,
        id_producto   NUMBER NOT NULL,
        cantidad      NUMBER NOT NULL,
        fecha_entrega DATE,
        resuelto      CHAR(1) DEFAULT 'N' NOT NULL CHECK (resuelto IN ('S','N')),
        observacion   VARCHAR2(200)
      )
    ]';
  EXCEPTION WHEN OTHERS THEN
    IF SQLCODE != c_e_obj_exists THEN RAISE; END IF;
  END;

  -- Secuencia
  BEGIN
    EXECUTE IMMEDIATE q'[CREATE SEQUENCE seq_pendiente_vacio START WITH 1 INCREMENT BY 1 NOCACHE]';
  EXCEPTION WHEN OTHERS THEN
    IF SQLCODE != c_e_obj_exists THEN RAISE; END IF;
  END;

  -- Trigger autoincremental
  BEGIN
    EXECUTE IMMEDIATE q'[
      CREATE OR REPLACE TRIGGER bi_pendiente_vacio
      BEFORE INSERT ON pendiente_vacio
      FOR EACH ROW
      WHEN (NEW.id_pend IS NULL)
      BEGIN
        :NEW.id_pend := seq_pendiente_vacio.NEXTVAL;
      END;
    ]';
  END;

  -- FKs (tolerantes a re-ejecución)
  BEGIN
    EXECUTE IMMEDIATE
      'ALTER TABLE pendiente_vacio ADD CONSTRAINT fk_pend_vacio__cliente
         FOREIGN KEY (id_cliente) REFERENCES cliente(id_cliente)';
  EXCEPTION WHEN OTHERS THEN
    IF SQLCODE NOT IN (c_e_fk_exists, c_e_fk_dup) THEN RAISE; END IF;
  END;

  BEGIN
    EXECUTE IMMEDIATE
      'ALTER TABLE pendiente_vacio ADD CONSTRAINT fk_pend_vacio__producto
         FOREIGN KEY (id_producto) REFERENCES producto(id_producto)';
  EXCEPTION WHEN OTHERS THEN
    IF SQLCODE NOT IN (c_e_fk_exists, c_e_fk_dup) THEN RAISE; END IF;
  END;

  -- Vista
  EXECUTE IMMEDIATE q'[
    CREATE OR REPLACE VIEW v_pendiente_vacio_activo AS
    SELECT p.* FROM pendiente_vacio p WHERE p.resuelto = 'N'
  ]';
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('023-pendientes-vacio', 'sgbd', 'changelog/023-pendientes-vacio.xml', SYSTIMESTAMP, 37, '9:c72dfceb1731b138ab1b26521feb1508', 'sqlFile path=../../ddl/023_pendientes_vacio.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/024-compras.xml::024-compras-ddl::sgbd
-- Compras (solo DDL; la procedure va en 024_compras_proc.sql)

CREATE TABLE compra (
  id_compra            NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nro_pedido           VARCHAR2(40),
  nro_factura          VARCHAR2(40),
  forma_pago           VARCHAR2(30),
  id_proveedor         NUMBER NOT NULL,
  fecha                DATE DEFAULT TRUNC(SYSDATE) NOT NULL,
  id_ubicacion_destino NUMBER NOT NULL,
  subtotal             NUMBER,
  iva                  NUMBER,
  total                NUMBER,
  CONSTRAINT pk_compra PRIMARY KEY (id_compra)
);

ALTER TABLE compra
  ADD CONSTRAINT fk_compra__proveedor
  FOREIGN KEY (id_proveedor) REFERENCES proveedor(id_proveedor);

ALTER TABLE compra
  ADD CONSTRAINT fk_compra__ubic_dest
  FOREIGN KEY (id_ubicacion_destino) REFERENCES ubicacion(id_ubicacion);

CREATE TABLE compra_det (
  id_compra          NUMBER NOT NULL,
  id_producto        NUMBER NOT NULL,
  cantidad           NUMBER NOT NULL,
  costo_unit_con_iva NUMBER,
  costo_unit_sin_iva NUMBER,
  CONSTRAINT pk_compra_det PRIMARY KEY (id_compra, id_producto)
);

ALTER TABLE compra_det
  ADD CONSTRAINT fk_compra_det__compra
  FOREIGN KEY (id_compra) REFERENCES compra(id_compra) ON DELETE CASCADE;

ALTER TABLE compra_det
  ADD CONSTRAINT fk_compra_det__producto
  FOREIGN KEY (id_producto) REFERENCES producto(id_producto);

CREATE INDEX ix_compra__nro_pedido  ON compra (nro_pedido);

CREATE INDEX ix_compra__nro_factura ON compra (nro_factura);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('024-compras-ddl', 'sgbd', 'changelog/024-compras.xml', SYSTIMESTAMP, 38, '9:fec822119e323243b59a60c6925c1069', 'sqlFile path=../../ddl/024_compras.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/024-compras.xml::024-compras-proc::sgbd
CREATE OR REPLACE PROCEDURE pr_registrar_compra(p_id_compra IN NUMBER) IS
  v_dest NUMBER;
BEGIN
  SELECT id_ubicacion_destino INTO v_dest
    FROM compra
   WHERE id_compra = p_id_compra;

  FOR r IN (
    SELECT id_producto, cantidad
      FROM compra_det
     WHERE id_compra = p_id_compra
  ) LOOP
    MERGE INTO stock_ubicacion su
    USING dual
      ON (su.id_ubicacion = v_dest AND su.id_producto = r.id_producto)
    WHEN MATCHED THEN
      UPDATE SET su.llenos = su.llenos + r.cantidad,
                 su.fecha_actualizacion = SYSTIMESTAMP
    WHEN NOT MATCHED THEN
      INSERT (id_ubicacion, id_producto, llenos, vacios, fecha_actualizacion)
      VALUES (v_dest, r.id_producto, r.cantidad, 0, SYSTIMESTAMP);

    INSERT INTO movimiento_stock
      (fecha, tipo, id_ubicacion_hasta, id_producto, cantidad, es_lleno, ref_tipo, ref_id)
    VALUES
      (SYSTIMESTAMP, 'COMPRA', v_dest, r.id_producto, r.cantidad, 'S', 'COMPRA', p_id_compra);
  END LOOP;
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('024-compras-proc', 'sgbd', 'changelog/024-compras.xml', SYSTIMESTAMP, 39, '9:01bb2c5f4098d2af0fff0795187cb271', 'sqlFile path=../../ddl/024_compras_proc.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/025-ventas-ubicacion.xml::025-ventas-ubicacion::sgbd
-- Ventas con origen de ubicacion

-- 1) Obtener id de LOCAL y asegurar columna
DECLARE
  v_local_id NUMBER;
BEGIN
  SELECT id_ubicacion INTO v_local_id
  FROM ubicacion
  WHERE nombre = 'LOCAL';

  -- Agregar columna si no existe
  BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE boleta_venta ADD (origen_ubicacion NUMBER)';
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE != -1430 THEN RAISE; END IF; -- ORA-01430: column exists
  END;
END;

-- 2) Inicializar la columna (dinámico para que compile aunque la columna no existiera antes)
DECLARE
  v_local_id NUMBER;
BEGIN
  SELECT id_ubicacion INTO v_local_id
  FROM ubicacion
  WHERE nombre = 'LOCAL';

  EXECUTE IMMEDIATE
    'UPDATE boleta_venta
        SET origen_ubicacion = :1
      WHERE origen_ubicacion IS NULL'
    USING v_local_id;
END;

-- 3) Default + NOT NULL (dinámico, tolerante)
DECLARE
  v_local_id NUMBER;
BEGIN
  SELECT id_ubicacion INTO v_local_id
  FROM ubicacion
  WHERE nombre = 'LOCAL';

  BEGIN
    EXECUTE IMMEDIATE
      'ALTER TABLE boleta_venta MODIFY (origen_ubicacion NUMBER DEFAULT '||v_local_id||' NOT NULL)';
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE != -1442 THEN RAISE; END IF; -- ya tenía NN/DEFAULT
  END;
END;

-- 4) FK (dinámico, tolerante)
BEGIN
  BEGIN
    EXECUTE IMMEDIATE
      'ALTER TABLE boleta_venta
         ADD CONSTRAINT fk_boleta__origen_ubi
             FOREIGN KEY (origen_ubicacion)
             REFERENCES ubicacion(id_ubicacion)';
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE != -2275 THEN RAISE; END IF; -- FK ya existía
  END;
END;

-- 5) (recrear procedure)

BEGIN
  EXECUTE IMMEDIATE 'DROP PROCEDURE pr_registrar_venta';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -4043 THEN RAISE; END IF; -- no existe
END;

CREATE OR REPLACE PROCEDURE pr_registrar_venta(p_id_boleta IN NUMBER) IS
  v_origen   NUMBER;
  v_cliente  NUMBER;
BEGIN
  SELECT origen_ubicacion, id_cliente
    INTO v_origen, v_cliente
    FROM boleta_venta
   WHERE id_boleta = p_id_boleta;

  FOR r IN (
    SELECT id_producto, cantidad
      FROM boleta_venta_detalle
     WHERE id_boleta = p_id_boleta
  ) LOOP
    MERGE INTO stock_ubicacion su
    USING dual
      ON (su.id_ubicacion = v_origen AND su.id_producto = r.id_producto)
    WHEN MATCHED THEN
      UPDATE SET su.llenos = su.llenos - r.cantidad,
                 su.fecha_actualizacion = SYSTIMESTAMP
    WHEN NOT MATCHED THEN
      INSERT (id_ubicacion, id_producto, llenos, vacios, fecha_actualizacion)
      VALUES (v_origen, r.id_producto, -r.cantidad, 0, SYSTIMESTAMP);

    INSERT INTO movimiento_stock (fecha, tipo, id_ubicacion_desde, id_producto, cantidad, es_lleno, ref_tipo, ref_id)
    VALUES (SYSTIMESTAMP, 'VENTA', v_origen, r.id_producto, r.cantidad, 'S', 'VENTA', p_id_boleta);

    IF v_cliente IS NOT NULL THEN
      INSERT INTO pendiente_vacio (id_cliente, id_producto, cantidad, fecha_entrega)
      VALUES (v_cliente, r.id_producto, r.cantidad, TRUNC(SYSDATE));
    END IF;
  END LOOP;
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('025-ventas-ubicacion', 'sgbd', 'changelog/025-ventas-ubicacion.xml', SYSTIMESTAMP, 40, '9:5b95cd4f667d506bd24dd0938de6ee94', 'sqlFile path=../../ddl/025_ventas_ubicacion.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/026-caja-cuentas.xml::026-caja-cuentas::sgbd
-- Caja y cuentas

CREATE TABLE caja_mov (
  id          NUMBER GENERATED BY DEFAULT AS IDENTITY,
  fecha       TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  tipo        VARCHAR2(10) NOT NULL CHECK (tipo IN ('INGRESO','EGRESO')),
  medio_pago  VARCHAR2(15) NOT NULL CHECK (medio_pago IN ('EFECTIVO','TRANSFERENCIA','TARJETA')),
  monto       NUMBER(14,2) NOT NULL,
  ref_tipo    VARCHAR2(30),
  ref_id      NUMBER,
  observacion VARCHAR2(200),
  CONSTRAINT pk_caja_mov PRIMARY KEY (id)
);

CREATE TABLE cuenta_corriente (
  id     NUMBER GENERATED BY DEFAULT AS IDENTITY,
  banco  VARCHAR2(60) NOT NULL,
  numero VARCHAR2(60) NOT NULL,
  saldo  NUMBER(14,2) DEFAULT 0 NOT NULL,
  CONSTRAINT pk_cuenta_corriente PRIMARY KEY (id)
);

CREATE TABLE cta_cobrar (
  id_cc           NUMBER GENERATED BY DEFAULT AS IDENTITY,
  id_cliente      NUMBER NOT NULL,
  nro_factura     VARCHAR2(40),
  fecha_venta     DATE NOT NULL,
  plazo_dias      NUMBER DEFAULT 0 NOT NULL,
  direccion       VARCHAR2(200),
  telefono        VARCHAR2(60),
  monto_total     NUMBER(14,2) NOT NULL,
  saldo_pendiente NUMBER(14,2) NOT NULL,
  estado          VARCHAR2(10) DEFAULT 'ABIERTA' NOT NULL CHECK (estado IN ('ABIERTA','PAGADA','VENCIDA')),
  CONSTRAINT pk_cta_cobrar PRIMARY KEY (id_cc)
);

CREATE TABLE epp_mov (
  id        NUMBER GENERATED BY DEFAULT AS IDENTITY,
  fecha     TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  empleado  VARCHAR2(100) NOT NULL,
  recurso   VARCHAR2(100) NOT NULL,
  cantidad  NUMBER NOT NULL,
  tipo      VARCHAR2(10) NOT NULL CHECK (tipo IN ('ENTREGA','DEVOLUCION')),
  CONSTRAINT pk_epp_mov PRIMARY KEY (id)
);

ALTER TABLE cta_cobrar ADD CONSTRAINT fk_cta_cobrar__cliente FOREIGN KEY (id_cliente) REFERENCES cliente(id_cliente);

CREATE VIEW v_caja_saldo AS
SELECT medio_pago,
       SUM(CASE WHEN tipo = 'INGRESO' THEN monto ELSE -monto END) saldo
FROM caja_mov
GROUP BY medio_pago;

CREATE VIEW v_cta_cobrar_saldo AS
SELECT id_cliente,
       SUM(saldo_pendiente) saldo
FROM cta_cobrar
GROUP BY id_cliente;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('026-caja-cuentas', 'sgbd', 'changelog/026-caja-cuentas.xml', SYSTIMESTAMP, 41, '9:47d77fb8dd202d300617a743925888f8', 'sqlFile path=../../ddl/026_caja_cuentas.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/027-lista-precios.xml::027-lista-precios::sgbd
-- Lista de precios (idempotente)

-- Crear tabla LISTA_PRECIO si no existe
DECLARE
  v_cnt PLS_INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_cnt
  FROM user_tables
  WHERE table_name = 'LISTA_PRECIO';

  IF v_cnt = 0 THEN
    EXECUTE IMMEDIATE q'[
CREATE TABLE lista_precio (
  id_lista      NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nombre        VARCHAR2(100) NOT NULL,
  vigente_desde DATE NOT NULL,
  vigente_hasta DATE,
  CONSTRAINT pk_lista_precio PRIMARY KEY (id_lista),
  CONSTRAINT uq_lista_precio__nombre UNIQUE (nombre)
)]';
  END IF;
END;

-- Crear tabla LISTA_PRECIO_DET si no existe
DECLARE
  v_cnt PLS_INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_cnt
  FROM user_tables
  WHERE table_name = 'LISTA_PRECIO_DET';

  IF v_cnt = 0 THEN
    EXECUTE IMMEDIATE q'[
CREATE TABLE lista_precio_det (
  id_lista        NUMBER NOT NULL,
  id_producto     NUMBER NOT NULL,
  precio_con_iva  NUMBER(14,2) NOT NULL,
  CONSTRAINT pk_lista_precio_det PRIMARY KEY (id_lista, id_producto)
)]';
  END IF;
END;

-- FK fk_lpd__lista (si no existe)
DECLARE
  v_cnt PLS_INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_cnt
  FROM user_constraints
  WHERE table_name = 'LISTA_PRECIO_DET'
    AND constraint_name = 'FK_LPD__LISTA';

  IF v_cnt = 0 THEN
    EXECUTE IMMEDIATE
      'ALTER TABLE lista_precio_det '||
      'ADD CONSTRAINT fk_lpd__lista FOREIGN KEY (id_lista) REFERENCES lista_precio(id_lista)';
  END IF;
END;

-- FK fk_lpd__producto (si no existe)
DECLARE
  v_cnt PLS_INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_cnt
  FROM user_constraints
  WHERE table_name = 'LISTA_PRECIO_DET'
    AND constraint_name = 'FK_LPD__PRODUCTO';

  IF v_cnt = 0 THEN
    EXECUTE IMMEDIATE
      'ALTER TABLE lista_precio_det '||
      'ADD CONSTRAINT fk_lpd__producto FOREIGN KEY (id_producto) REFERENCES producto(id_producto)';
  END IF;
END;

-- Semilla de la lista base (id=1)
MERGE INTO lista_precio lp
USING (SELECT 1 id_lista, 'BASE 2025' nombre FROM dual) s
ON (lp.id_lista = s.id_lista)
WHEN NOT MATCHED THEN
  INSERT (id_lista, nombre, vigente_desde)
  VALUES (s.id_lista, s.nombre, DATE '2025-01-01');

-- Poblar detalle desde producto
MERGE INTO lista_precio_det lpd
USING (
  SELECT 1 id_lista, id_producto, precio precio_con_iva
  FROM producto
) s
ON (lpd.id_lista = s.id_lista AND lpd.id_producto = s.id_producto)
WHEN NOT MATCHED THEN
  INSERT (id_lista, id_producto, precio_con_iva)
  VALUES (s.id_lista, s.id_producto, s.precio_con_iva);

-- Parametrizar lista activa en PARAMETRO_SISTEMA
MERGE INTO parametro_sistema ps
USING (
  SELECT
    'PRECIO_LISTA_ACTIVA_ID' codigo,
    1                        valor_num,
    'Id de la lista de precios activa' descripcion
  FROM dual
) s
ON (ps.codigo = s.codigo)
WHEN MATCHED THEN
  UPDATE SET ps.valor_num   = s.valor_num,
             ps.descripcion = s.descripcion
WHEN NOT MATCHED THEN
  INSERT (codigo, valor_num, valor_texto, descripcion)
  VALUES (s.codigo, s.valor_num, NULL, s.descripcion);

-- Vista con precios actuales según lista activa
CREATE OR REPLACE VIEW v_precio_actual AS
SELECT p.id_producto,
       p.sku,
       p.nombre,
       d.precio_con_iva
FROM producto p
JOIN lista_precio_det d ON d.id_producto = p.id_producto
JOIN lista_precio     lp ON lp.id_lista   = d.id_lista
WHERE lp.id_lista = (
  SELECT valor_num
  FROM parametro_sistema
  WHERE codigo = 'PRECIO_LISTA_ACTIVA_ID'
);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('027-lista-precios', 'sgbd', 'changelog/027-lista-precios.xml', SYSTIMESTAMP, 42, '9:b5de9613cb55fca7cca70802628ffdaa', 'sqlFile path=../../ddl/027_lista_precios.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/028-geo-clientes.xml::028-geo-clientes::sgbd
-- Geolocalización de clientes (idempotente)

-- lat
BEGIN
  EXECUTE IMMEDIATE 'ALTER TABLE cliente ADD (lat NUMBER(9,6))';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -1430 THEN RAISE; END IF; -- ORA-01430: columna ya existe
END;

-- lng
BEGIN
  EXECUTE IMMEDIATE 'ALTER TABLE cliente ADD (lng NUMBER(9,6))';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -1430 THEN RAISE; END IF;
END;

-- geo_precision
BEGIN
  EXECUTE IMMEDIATE 'ALTER TABLE cliente ADD (geo_precision VARCHAR2(30))';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -1430 THEN RAISE; END IF;
END;

-- geo_at
BEGIN
  EXECUTE IMMEDIATE 'ALTER TABLE cliente ADD (geo_at TIMESTAMP)';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -1430 THEN RAISE; END IF;
END;

CREATE OR REPLACE PROCEDURE pr_upd_geocoords(
  p_id_cliente IN cliente.id_cliente%TYPE,
  p_lat        IN NUMBER,
  p_lng        IN NUMBER,
  p_precision  IN VARCHAR2
) AS
BEGIN
  UPDATE cliente
     SET lat = p_lat,
         lng = p_lng,
         geo_precision = p_precision,
         geo_at = SYSTIMESTAMP
   WHERE id_cliente = p_id_cliente;
END;

CREATE OR REPLACE PROCEDURE pr_export_clientes_geo(
  p_filename IN VARCHAR2 DEFAULT 'clientes_geo.csv'
) IS
  f UTL_FILE.FILE_TYPE;
BEGIN
  f := UTL_FILE.FOPEN('EXPORT_DIR', p_filename, 'w', 32767);
  UTL_FILE.PUT_LINE(f, 'rut,nombre,direccion,telefono,lat,lng');

  FOR r IN (
    SELECT c.rut, c.nombre, c.direccion, c.telefono, c.lat, c.lng
      FROM cliente c
  ) LOOP
    UTL_FILE.PUT_LINE(f,
      csv_str(r.rut) || ',' ||
      csv_str(r.nombre) || ',' ||
      csv_str(r.direccion) || ',' ||
      csv_str(r.telefono) || ',' ||
      csv_num(r.lat) || ',' ||
      csv_num(r.lng)
    );
  END LOOP;

  UTL_FILE.FCLOSE(f);
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('028-geo-clientes', 'sgbd', 'changelog/028-geo-clientes.xml', SYSTIMESTAMP, 43, '9:1cd4b45a1a96512b627a9ddacb98765a', 'sqlFile path=../../ddl/028_geo_clientes.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/029-venta-idempotencia.xml::029-venta-idempotencia::sgbd
-- 29_venta_idempotencia.sql
-- Asegura columna/flag, normaliza histórico, índices de unicidad y procedure idempotente

--------------------------------------------------------------------------------
-- 1) Columna inventario_impactado si no existe
--------------------------------------------------------------------------------
DECLARE
  v_cnt PLS_INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_cnt
  FROM user_tab_columns
  WHERE table_name = 'BOLETA_VENTA'
    AND column_name = 'INVENTARIO_IMPACTADO';

  IF v_cnt = 0 THEN
    EXECUTE IMMEDIATE
      'ALTER TABLE boleta_venta
         ADD (inventario_impactado CHAR(1) DEFAULT ''N'' NOT NULL
              CHECK (inventario_impactado IN (''S'',''N'')))';
  END IF;
END;

--------------------------------------------------------------------------------
-- 2) Marcar boletas ya impactadas por movimientos VENTA
--------------------------------------------------------------------------------
UPDATE boleta_venta b
   SET inventario_impactado = 'S'
 WHERE NVL(inventario_impactado,'N') <> 'S'
   AND EXISTS (
     SELECT 1
       FROM movimiento_stock m
      WHERE m.ref_tipo = 'VENTA'
        AND m.ref_id   = b.id_boleta
   );

--------------------------------------------------------------------------------
-- 3) Índice único para no duplicar movimientos VENTA
--------------------------------------------------------------------------------
BEGIN
  EXECUTE IMMEDIATE
    'CREATE UNIQUE INDEX uq_mov_venta_unico
       ON movimiento_stock (
         CASE WHEN ref_tipo = ''VENTA'' THEN ref_id       END,
         CASE WHEN ref_tipo = ''VENTA'' THEN id_producto  END,
         CASE WHEN ref_tipo = ''VENTA'' THEN tipo         END,
         CASE WHEN ref_tipo = ''VENTA'' THEN es_lleno     END
       )';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -955 THEN RAISE; END IF; -- ya existe
END;

--------------------------------------------------------------------------------
-- 4) Índice único: un pendiente activo por cliente/producto
--------------------------------------------------------------------------------
BEGIN
  EXECUTE IMMEDIATE
    'CREATE UNIQUE INDEX uq_pend_vacio_activo
       ON pendiente_vacio (
         CASE WHEN resuelto = ''N'' THEN id_cliente  END,
         CASE WHEN resuelto = ''N'' THEN id_producto END
       )';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -955 THEN RAISE; END IF; -- ya existe
END;

--------------------------------------------------------------------------------
-- 5) Procedure idempotente
--------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE pr_registrar_venta(p_id_boleta IN NUMBER) IS
  v_cliente NUMBER;
  v_origen  NUMBER;
  v_flag    CHAR(1);
  v_disp    NUMBER;
BEGIN
  -- Tomar boleta y bloquear fila (evita doble impacto concurrente)
  BEGIN
    SELECT id_cliente,
           origen_ubicacion,
           NVL(inventario_impactado,'N')
      INTO v_cliente, v_origen, v_flag
      FROM boleta_venta
     WHERE id_boleta = p_id_boleta
     FOR UPDATE;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20002, 'No existe boleta '||p_id_boleta);
  END;

  -- Idempotencia: ya impactada -> salir
  IF v_flag = 'S' THEN
    RETURN;
  END IF;

  -- Por cada línea de detalle
  FOR r IN (
    SELECT id_producto, cantidad
      FROM boleta_venta_detalle
     WHERE id_boleta = p_id_boleta
  ) LOOP
    -- Stock disponible en origen (si no hay fila, 0)
    BEGIN
      SELECT NVL(llenos,0)
        INTO v_disp
        FROM stock_ubicacion
       WHERE id_ubicacion = v_origen
         AND id_producto  = r.id_producto
       FOR UPDATE;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_disp := 0;
    END;

    IF v_disp < r.cantidad THEN
      RAISE_APPLICATION_ERROR(
        -20001,
        'Stock insuficiente en origen para producto '||r.id_producto||
        ' (disp='||v_disp||', req='||r.cantidad||')'
      );
    END IF;

    -- Descontar stock
    UPDATE stock_ubicacion
       SET llenos = llenos - r.cantidad,
           fecha_actualizacion = SYSTIMESTAMP
     WHERE id_ubicacion = v_origen
       AND id_producto  = r.id_producto;

    -- Movimiento VENTA (resiliente ante reintentos)
    BEGIN
      INSERT INTO movimiento_stock
        (fecha, tipo, id_ubicacion_desde, id_producto, cantidad, es_lleno, ref_tipo, ref_id)
      VALUES
        (SYSTIMESTAMP, 'VENTA', v_origen, r.id_producto, r.cantidad, 'S', 'VENTA', p_id_boleta);
    EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN NULL;
    END;

    -- Pendiente de vacío idempotente (una fila activa por cliente/producto)
    MERGE INTO pendiente_vacio p
    USING (
      SELECT v_cliente     AS id_cliente,
             r.id_producto AS id_producto,
             r.cantidad    AS cantidad
      FROM dual
    ) s
      ON ( p.id_cliente = s.id_cliente
       AND p.id_producto = s.id_producto
       AND p.resuelto   = 'N')
    WHEN MATCHED THEN
      UPDATE SET p.cantidad = p.cantidad + s.cantidad
    WHEN NOT MATCHED THEN
      INSERT (id_cliente, id_producto, cantidad, resuelto)
      VALUES (s.id_cliente, s.id_producto, s.cantidad, 'N');
  END LOOP;

  -- Marcar boleta como impactada
  UPDATE boleta_venta
     SET inventario_impactado = 'S'
   WHERE id_boleta = p_id_boleta;

  COMMIT;
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('029-venta-idempotencia', 'sgbd', 'changelog/029-venta-idempotencia.xml', SYSTIMESTAMP, 44, '9:3839ff99efe3b0e4ec9e5456c73496b2', 'sqlFile path=../../ddl/29_venta_idempotencia.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/030-app-context.xml::030-app-context-pkg::sgbd
CREATE OR REPLACE PACKAGE pkg_app_ctx AS
  PROCEDURE set_usuario(p_id NUMBER);
END;
/

CREATE OR REPLACE PACKAGE BODY pkg_app_ctx AS
  PROCEDURE set_usuario(p_id NUMBER) IS
  BEGIN
    DBMS_SESSION.SET_CONTEXT('APP_PYME_CTX','ID_USUARIO', TO_CHAR(p_id));
  END;
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('030-app-context-pkg', 'sgbd', 'changelog/030-app-context.xml', SYSTIMESTAMP, 45, '9:0466594827ae946b9de804678d1f3641', 'sqlFile path=../../ddl/30_app_context_pkg.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/030-app-context.xml::030-app-context-createctx::sgbd
DECLARE
  -- ya existe (dos variantes posibles según versión)
  e_ctx_exists_29443 EXCEPTION; PRAGMA EXCEPTION_INIT(e_ctx_exists_29443, -29443);
  e_ctx_exists_955   EXCEPTION; PRAGMA EXCEPTION_INIT(e_ctx_exists_955,   -955);
  -- falta privilegio (si lo crea SYS)
  e_no_priv          EXCEPTION; PRAGMA EXCEPTION_INIT(e_no_priv,          -1031);
BEGIN
  EXECUTE IMMEDIATE 'CREATE CONTEXT app_pyme_ctx USING pkg_app_ctx';
EXCEPTION
  WHEN e_ctx_exists_29443 THEN NULL; -- ya existe
  WHEN e_ctx_exists_955   THEN NULL; -- ya existe
  WHEN e_no_priv          THEN NULL; -- sin privilegio aquí (lo creó SYS)
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('030-app-context-createctx', 'sgbd', 'changelog/030-app-context.xml', SYSTIMESTAMP, 46, '9:138916565f831eef644e8f69e36f9992', 'sqlFile path=../../ddl/30_app_context_createctx.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/031-trigger-boleta-usuario.xml::031-trigger-boleta-usuario::sgbd
-- Trigger: si no viene el id_usuario_vende, lo toma del contexto
CREATE OR REPLACE TRIGGER trg_boleta_set_usuario
BEFORE INSERT ON boleta_venta
FOR EACH ROW
DECLARE
  v_ctx VARCHAR2(30);
BEGIN
  IF :NEW.id_usuario_vende IS NULL THEN
    v_ctx := SYS_CONTEXT('APP_PYME_CTX','ID_USUARIO');
    IF v_ctx IS NULL THEN
      RAISE_APPLICATION_ERROR(-20050, 'ID_USUARIO no seteado en contexto de sesión');
    END IF;
    :NEW.id_usuario_vende := TO_NUMBER(v_ctx);
  END IF;
END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('031-trigger-boleta-usuario', 'sgbd', 'changelog/031-trigger-boleta-usuario.xml', SYSTIMESTAMP, 47, '9:f384e4f05d0983af167d0f15309645b8', 'sqlFile path=../../ddl/31_trigger_boleta_usuario.sql', '', 'EXECUTED', NULL, NULL, '4.33.0', '7124371332');

-- Changeset changelog/032-seed-precios-producto.xml::018-seed-precios-producto::sgbd
MERGE INTO producto p
USING (
  SELECT 'GAS-5'  sku, 'Cilindro Gas 5 Kg'  nombre, 10811 costo, 13300 precio FROM dual UNION ALL
  SELECT 'GAS-11' sku, 'Cilindro Gas 11 Kg' nombre, 22340 costo, 25000 precio FROM dual UNION ALL
  SELECT 'GAS-15' sku, 'Cilindro Gas 15 Kg' nombre, 21354 costo, 26000 precio FROM dual UNION ALL
  SELECT 'GAS-45' sku, 'Cilindro Gas 45 Kg' nombre, 82297 costo, 91500 precio FROM dual UNION ALL
  SELECT 'GAS-VMF' sku,'Cilindro Gas VMF'   nombre, 31479 costo, 35000 precio FROM dual UNION ALL
  SELECT 'GAS-VMA' sku,'Cilindro Gas VMA'   nombre, 32379 costo, 36000 precio FROM dual
) s
ON (p.sku = s.sku)
WHEN MATCHED THEN
  UPDATE SET p.costo  = s.costo,
             p.precio = s.precio
WHEN NOT MATCHED THEN
  INSERT (sku, nombre, costo, precio)
  VALUES (s.sku, s.nombre, s.costo, s.precio);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('018-seed-precios-producto', 'sgbd', 'changelog/032-seed-precios-producto.xml', SYSTIMESTAMP, 48, '9:537cc079cecfc6a9bd1b1cd7e6e18bd7', 'sqlFile path=../../ddl/18_seed_precios_producto.sql', '', 'EXECUTED', '(!admin,seed)', NULL, '4.33.0', '7124371332');

-- Changeset changelog/033-seq-trg-boleta-numero.xml::019a-seq-boleta-numero::sgbd
CREATE SEQUENCE APP_PYME.SEQ_BOLETA_NUMERO START WITH 1 INCREMENT BY 1 CACHE 20;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('019a-seq-boleta-numero', 'sgbd', 'changelog/033-seq-trg-boleta-numero.xml', SYSTIMESTAMP, 49, '9:bd846a7c13182240c18066a99e771f23', 'createSequence sequenceName=SEQ_BOLETA_NUMERO', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/033-seq-trg-boleta-numero.xml::019b-trg-boleta-set-numero::sgbd
CREATE OR REPLACE TRIGGER TRG_BOLETA_SET_NUMERO
      BEFORE INSERT ON boleta_venta
      FOR EACH ROW
      WHEN (NEW.numero IS NULL)
      BEGIN
        :NEW.numero := SEQ_BOLETA_NUMERO.NEXTVAL;
      END;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('019b-trg-boleta-set-numero', 'sgbd', 'changelog/033-seq-trg-boleta-numero.xml', SYSTIMESTAMP, 50, '9:ac4ac2adeecb0b8f10d9844017803c53', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/035-repair-mvs-views.xml::035a-mv-vd-create-if-missing::sgbd
CREATE MATERIALIZED VIEW mv_ventas_diarias
      BUILD IMMEDIATE
      REFRESH COMPLETE ON DEMAND
      AS
      SELECT TRUNC(b.fecha) AS dia,
             SUM(b.total)   AS total_ventas,
             SUM(b.neto)    AS total_neto,
             SUM(b.iva)     AS total_iva
        FROM boleta_venta b
       WHERE b.estado = 'PAGADA'
       GROUP BY TRUNC(b.fecha);

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('035a-mv-vd-create-if-missing', 'sgbd', 'changelog/035-repair-mvs-views.xml', SYSTIMESTAMP, 51, '9:69c1f102c9c3dd15e78171a1c216f202', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/035-repair-mvs-views.xml::035b-mv-vpp-compile-if-exists::sgbd
ALTER MATERIALIZED VIEW mv_ventas_por_producto COMPILE;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('035b-mv-vpp-compile-if-exists', 'sgbd', 'changelog/035-repair-mvs-views.xml', SYSTIMESTAMP, 52, '9:5d6026687f8d31dc8e51663078b8cc7e', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/035-repair-mvs-views.xml::035c-view-kpi-vd-if-mv::sgbd
CREATE OR REPLACE VIEW v_kpi_ventas_diarias AS
      SELECT dia, total_ventas, total_neto, total_iva
      FROM mv_ventas_diarias;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('035c-view-kpi-vd-if-mv', 'sgbd', 'changelog/035-repair-mvs-views.xml', SYSTIMESTAMP, 53, '9:3bc2f01e1dc7a436d2c4db4fcda7b07a', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Changeset changelog/035-repair-mvs-views.xml::035d-view-kpi-vpp-if-mv::sgbd
CREATE OR REPLACE VIEW v_kpi_ventas_por_producto AS
      SELECT sku, nombre, unidades_vendidas, monto_vendido, costo_estimado, utilidad_estimada
      FROM mv_ventas_por_producto;

INSERT INTO APP_PYME.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('035d-view-kpi-vpp-if-mv', 'sgbd', 'changelog/035-repair-mvs-views.xml', SYSTIMESTAMP, 54, '9:ee70f7464ccdbf0eb8498168bdcce0f1', 'sql', '', 'EXECUTED', '!admin', NULL, '4.33.0', '7124371332');

-- Release Database Lock
UPDATE APP_PYME.DATABASECHANGELOGLOCK SET LOCKED = 0, LOCKEDBY = NULL, LOCKGRANTED = NULL WHERE ID = 1;

